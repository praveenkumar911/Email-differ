{"ast":null,"code":"import _objectSpread from \"/home/rcts/Email-differ/Frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { EndpointError } from \"../types\";\nimport { evaluateConditions } from \"./evaluateConditions\";\nimport { evaluateEndpointRule } from \"./evaluateEndpointRule\";\nimport { evaluateErrorRule } from \"./evaluateErrorRule\";\nexport const evaluateRules = (rules, options) => {\n  for (const rule of rules) {\n    if (rule.type === \"endpoint\") {\n      const endpointOrUndefined = evaluateEndpointRule(rule, options);\n      if (endpointOrUndefined) {\n        return endpointOrUndefined;\n      }\n    } else if (rule.type === \"error\") {\n      evaluateErrorRule(rule, options);\n    } else if (rule.type === \"tree\") {\n      const endpointOrUndefined = group.evaluateTreeRule(rule, options);\n      if (endpointOrUndefined) {\n        return endpointOrUndefined;\n      }\n    } else {\n      throw new EndpointError(\"Unknown endpoint rule: \".concat(rule));\n    }\n  }\n  throw new EndpointError(\"Rules evaluation failed\");\n};\nexport const evaluateTreeRule = (treeRule, options) => {\n  const {\n    conditions,\n    rules\n  } = treeRule;\n  const {\n    result,\n    referenceRecord\n  } = evaluateConditions(conditions, options);\n  if (!result) {\n    return;\n  }\n  return group.evaluateRules(rules, _objectSpread(_objectSpread({}, options), {}, {\n    referenceRecord: _objectSpread(_objectSpread({}, options.referenceRecord), referenceRecord)\n  }));\n};\nexport const group = {\n  evaluateRules,\n  evaluateTreeRule\n};","map":{"version":3,"names":["EndpointError","evaluateConditions","evaluateEndpointRule","evaluateErrorRule","evaluateRules","rules","options","rule","type","endpointOrUndefined","group","evaluateTreeRule","concat","treeRule","conditions","result","referenceRecord","_objectSpread"],"sources":["/home/rcts/Email-differ/Frontend/node_modules/@smithy/util-endpoints/dist-es/utils/evaluateRules.js"],"sourcesContent":["import { EndpointError } from \"../types\";\nimport { evaluateConditions } from \"./evaluateConditions\";\nimport { evaluateEndpointRule } from \"./evaluateEndpointRule\";\nimport { evaluateErrorRule } from \"./evaluateErrorRule\";\nexport const evaluateRules = (rules, options) => {\n    for (const rule of rules) {\n        if (rule.type === \"endpoint\") {\n            const endpointOrUndefined = evaluateEndpointRule(rule, options);\n            if (endpointOrUndefined) {\n                return endpointOrUndefined;\n            }\n        }\n        else if (rule.type === \"error\") {\n            evaluateErrorRule(rule, options);\n        }\n        else if (rule.type === \"tree\") {\n            const endpointOrUndefined = group.evaluateTreeRule(rule, options);\n            if (endpointOrUndefined) {\n                return endpointOrUndefined;\n            }\n        }\n        else {\n            throw new EndpointError(`Unknown endpoint rule: ${rule}`);\n        }\n    }\n    throw new EndpointError(`Rules evaluation failed`);\n};\nexport const evaluateTreeRule = (treeRule, options) => {\n    const { conditions, rules } = treeRule;\n    const { result, referenceRecord } = evaluateConditions(conditions, options);\n    if (!result) {\n        return;\n    }\n    return group.evaluateRules(rules, {\n        ...options,\n        referenceRecord: { ...options.referenceRecord, ...referenceRecord },\n    });\n};\nexport const group = {\n    evaluateRules,\n    evaluateTreeRule,\n};\n"],"mappings":";AAAA,SAASA,aAAa,QAAQ,UAAU;AACxC,SAASC,kBAAkB,QAAQ,sBAAsB;AACzD,SAASC,oBAAoB,QAAQ,wBAAwB;AAC7D,SAASC,iBAAiB,QAAQ,qBAAqB;AACvD,OAAO,MAAMC,aAAa,GAAGA,CAACC,KAAK,EAAEC,OAAO,KAAK;EAC7C,KAAK,MAAMC,IAAI,IAAIF,KAAK,EAAE;IACtB,IAAIE,IAAI,CAACC,IAAI,KAAK,UAAU,EAAE;MAC1B,MAAMC,mBAAmB,GAAGP,oBAAoB,CAACK,IAAI,EAAED,OAAO,CAAC;MAC/D,IAAIG,mBAAmB,EAAE;QACrB,OAAOA,mBAAmB;MAC9B;IACJ,CAAC,MACI,IAAIF,IAAI,CAACC,IAAI,KAAK,OAAO,EAAE;MAC5BL,iBAAiB,CAACI,IAAI,EAAED,OAAO,CAAC;IACpC,CAAC,MACI,IAAIC,IAAI,CAACC,IAAI,KAAK,MAAM,EAAE;MAC3B,MAAMC,mBAAmB,GAAGC,KAAK,CAACC,gBAAgB,CAACJ,IAAI,EAAED,OAAO,CAAC;MACjE,IAAIG,mBAAmB,EAAE;QACrB,OAAOA,mBAAmB;MAC9B;IACJ,CAAC,MACI;MACD,MAAM,IAAIT,aAAa,2BAAAY,MAAA,CAA2BL,IAAI,CAAE,CAAC;IAC7D;EACJ;EACA,MAAM,IAAIP,aAAa,0BAA0B,CAAC;AACtD,CAAC;AACD,OAAO,MAAMW,gBAAgB,GAAGA,CAACE,QAAQ,EAAEP,OAAO,KAAK;EACnD,MAAM;IAAEQ,UAAU;IAAET;EAAM,CAAC,GAAGQ,QAAQ;EACtC,MAAM;IAAEE,MAAM;IAAEC;EAAgB,CAAC,GAAGf,kBAAkB,CAACa,UAAU,EAAER,OAAO,CAAC;EAC3E,IAAI,CAACS,MAAM,EAAE;IACT;EACJ;EACA,OAAOL,KAAK,CAACN,aAAa,CAACC,KAAK,EAAAY,aAAA,CAAAA,aAAA,KACzBX,OAAO;IACVU,eAAe,EAAAC,aAAA,CAAAA,aAAA,KAAOX,OAAO,CAACU,eAAe,GAAKA,eAAe;EAAE,EACtE,CAAC;AACN,CAAC;AACD,OAAO,MAAMN,KAAK,GAAG;EACjBN,aAAa;EACbO;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}