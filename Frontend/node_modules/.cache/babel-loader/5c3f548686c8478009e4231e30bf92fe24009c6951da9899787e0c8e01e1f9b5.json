{"ast":null,"code":"import { nv } from \"@smithy/core/serde\";\nimport { toUtf8 } from \"@smithy/util-utf8\";\nimport { alloc, extendedFloat16, extendedFloat32, extendedFloat64, extendedOneByte, majorList, majorMap, majorNegativeInt64, majorTag, majorUint64, majorUnstructuredByteString, majorUtf8String, minorIndefinite, specialFalse, specialNull, specialTrue, specialUndefined, tag } from \"./cbor-types\";\nconst USE_TEXT_DECODER = typeof TextDecoder !== \"undefined\";\nconst USE_BUFFER = typeof Buffer !== \"undefined\";\nlet payload = alloc(0);\nlet dataView = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);\nconst textDecoder = USE_TEXT_DECODER ? new TextDecoder() : null;\nlet _offset = 0;\nexport function setPayload(bytes) {\n  payload = bytes;\n  dataView = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);\n}\nexport function decode(at, to) {\n  if (at >= to) {\n    throw new Error(\"unexpected end of (decode) payload.\");\n  }\n  const major = (payload[at] & 0b11100000) >> 5;\n  const minor = payload[at] & 0b00011111;\n  switch (major) {\n    case majorUint64:\n    case majorNegativeInt64:\n    case majorTag:\n      let unsignedInt;\n      let offset;\n      if (minor < 24) {\n        unsignedInt = minor;\n        offset = 1;\n      } else {\n        switch (minor) {\n          case extendedOneByte:\n          case extendedFloat16:\n          case extendedFloat32:\n          case extendedFloat64:\n            const countLength = minorValueToArgumentLength[minor];\n            const countOffset = countLength + 1;\n            offset = countOffset;\n            if (to - at < countOffset) {\n              throw new Error(\"countLength \".concat(countLength, \" greater than remaining buf len.\"));\n            }\n            const countIndex = at + 1;\n            if (countLength === 1) {\n              unsignedInt = payload[countIndex];\n            } else if (countLength === 2) {\n              unsignedInt = dataView.getUint16(countIndex);\n            } else if (countLength === 4) {\n              unsignedInt = dataView.getUint32(countIndex);\n            } else {\n              unsignedInt = dataView.getBigUint64(countIndex);\n            }\n            break;\n          default:\n            throw new Error(\"unexpected minor value \".concat(minor, \".\"));\n        }\n      }\n      if (major === majorUint64) {\n        _offset = offset;\n        return castBigInt(unsignedInt);\n      } else if (major === majorNegativeInt64) {\n        let negativeInt;\n        if (typeof unsignedInt === \"bigint\") {\n          negativeInt = BigInt(-1) - unsignedInt;\n        } else {\n          negativeInt = -1 - unsignedInt;\n        }\n        _offset = offset;\n        return castBigInt(negativeInt);\n      } else {\n        if (minor === 2 || minor === 3) {\n          const length = decodeCount(at + offset, to);\n          let b = BigInt(0);\n          const start = at + offset + _offset;\n          for (let i = start; i < start + length; ++i) {\n            b = b << BigInt(8) | BigInt(payload[i]);\n          }\n          _offset = offset + _offset + length;\n          return minor === 3 ? -b - BigInt(1) : b;\n        } else if (minor === 4) {\n          const decimalFraction = decode(at + offset, to);\n          const [exponent, mantissa] = decimalFraction;\n          const normalizer = mantissa < 0 ? -1 : 1;\n          const mantissaStr = \"0\".repeat(Math.abs(exponent) + 1) + String(BigInt(normalizer) * BigInt(mantissa));\n          let numericString;\n          const sign = mantissa < 0 ? \"-\" : \"\";\n          numericString = exponent === 0 ? mantissaStr : mantissaStr.slice(0, mantissaStr.length + exponent) + \".\" + mantissaStr.slice(exponent);\n          numericString = numericString.replace(/^0+/g, \"\");\n          if (numericString === \"\") {\n            numericString = \"0\";\n          }\n          if (numericString[0] === \".\") {\n            numericString = \"0\" + numericString;\n          }\n          numericString = sign + numericString;\n          _offset = offset + _offset;\n          return nv(numericString);\n        } else {\n          const value = decode(at + offset, to);\n          const valueOffset = _offset;\n          _offset = offset + valueOffset;\n          return tag({\n            tag: castBigInt(unsignedInt),\n            value\n          });\n        }\n      }\n    case majorUtf8String:\n    case majorMap:\n    case majorList:\n    case majorUnstructuredByteString:\n      if (minor === minorIndefinite) {\n        switch (major) {\n          case majorUtf8String:\n            return decodeUtf8StringIndefinite(at, to);\n          case majorMap:\n            return decodeMapIndefinite(at, to);\n          case majorList:\n            return decodeListIndefinite(at, to);\n          case majorUnstructuredByteString:\n            return decodeUnstructuredByteStringIndefinite(at, to);\n        }\n      } else {\n        switch (major) {\n          case majorUtf8String:\n            return decodeUtf8String(at, to);\n          case majorMap:\n            return decodeMap(at, to);\n          case majorList:\n            return decodeList(at, to);\n          case majorUnstructuredByteString:\n            return decodeUnstructuredByteString(at, to);\n        }\n      }\n    default:\n      return decodeSpecial(at, to);\n  }\n}\nfunction bytesToUtf8(bytes, at, to) {\n  var _bytes$constructor;\n  if (USE_BUFFER && ((_bytes$constructor = bytes.constructor) === null || _bytes$constructor === void 0 ? void 0 : _bytes$constructor.name) === \"Buffer\") {\n    return bytes.toString(\"utf-8\", at, to);\n  }\n  if (textDecoder) {\n    return textDecoder.decode(bytes.subarray(at, to));\n  }\n  return toUtf8(bytes.subarray(at, to));\n}\nfunction demote(bigInteger) {\n  const num = Number(bigInteger);\n  if (num < Number.MIN_SAFE_INTEGER || Number.MAX_SAFE_INTEGER < num) {\n    console.warn(new Error(\"@smithy/core/cbor - truncating BigInt(\".concat(bigInteger, \") to \").concat(num, \" with loss of precision.\")));\n  }\n  return num;\n}\nconst minorValueToArgumentLength = {\n  [extendedOneByte]: 1,\n  [extendedFloat16]: 2,\n  [extendedFloat32]: 4,\n  [extendedFloat64]: 8\n};\nexport function bytesToFloat16(a, b) {\n  const sign = a >> 7;\n  const exponent = (a & 0b01111100) >> 2;\n  const fraction = (a & 0b00000011) << 8 | b;\n  const scalar = sign === 0 ? 1 : -1;\n  let exponentComponent;\n  let summation;\n  if (exponent === 0b00000) {\n    if (fraction === 0b0000000000) {\n      return 0;\n    } else {\n      exponentComponent = Math.pow(2, 1 - 15);\n      summation = 0;\n    }\n  } else if (exponent === 0b11111) {\n    if (fraction === 0b0000000000) {\n      return scalar * Infinity;\n    } else {\n      return NaN;\n    }\n  } else {\n    exponentComponent = Math.pow(2, exponent - 15);\n    summation = 1;\n  }\n  summation += fraction / 1024;\n  return scalar * (exponentComponent * summation);\n}\nfunction decodeCount(at, to) {\n  const minor = payload[at] & 0b00011111;\n  if (minor < 24) {\n    _offset = 1;\n    return minor;\n  }\n  if (minor === extendedOneByte || minor === extendedFloat16 || minor === extendedFloat32 || minor === extendedFloat64) {\n    const countLength = minorValueToArgumentLength[minor];\n    _offset = countLength + 1;\n    if (to - at < _offset) {\n      throw new Error(\"countLength \".concat(countLength, \" greater than remaining buf len.\"));\n    }\n    const countIndex = at + 1;\n    if (countLength === 1) {\n      return payload[countIndex];\n    } else if (countLength === 2) {\n      return dataView.getUint16(countIndex);\n    } else if (countLength === 4) {\n      return dataView.getUint32(countIndex);\n    }\n    return demote(dataView.getBigUint64(countIndex));\n  }\n  throw new Error(\"unexpected minor value \".concat(minor, \".\"));\n}\nfunction decodeUtf8String(at, to) {\n  const length = decodeCount(at, to);\n  const offset = _offset;\n  at += offset;\n  if (to - at < length) {\n    throw new Error(\"string len \".concat(length, \" greater than remaining buf len.\"));\n  }\n  const value = bytesToUtf8(payload, at, at + length);\n  _offset = offset + length;\n  return value;\n}\nfunction decodeUtf8StringIndefinite(at, to) {\n  at += 1;\n  const vector = [];\n  for (const base = at; at < to;) {\n    if (payload[at] === 0b11111111) {\n      const data = alloc(vector.length);\n      data.set(vector, 0);\n      _offset = at - base + 2;\n      return bytesToUtf8(data, 0, data.length);\n    }\n    const major = (payload[at] & 0b11100000) >> 5;\n    const minor = payload[at] & 0b00011111;\n    if (major !== majorUtf8String) {\n      throw new Error(\"unexpected major type \".concat(major, \" in indefinite string.\"));\n    }\n    if (minor === minorIndefinite) {\n      throw new Error(\"nested indefinite string.\");\n    }\n    const bytes = decodeUnstructuredByteString(at, to);\n    const length = _offset;\n    at += length;\n    for (let i = 0; i < bytes.length; ++i) {\n      vector.push(bytes[i]);\n    }\n  }\n  throw new Error(\"expected break marker.\");\n}\nfunction decodeUnstructuredByteString(at, to) {\n  const length = decodeCount(at, to);\n  const offset = _offset;\n  at += offset;\n  if (to - at < length) {\n    throw new Error(\"unstructured byte string len \".concat(length, \" greater than remaining buf len.\"));\n  }\n  const value = payload.subarray(at, at + length);\n  _offset = offset + length;\n  return value;\n}\nfunction decodeUnstructuredByteStringIndefinite(at, to) {\n  at += 1;\n  const vector = [];\n  for (const base = at; at < to;) {\n    if (payload[at] === 0b11111111) {\n      const data = alloc(vector.length);\n      data.set(vector, 0);\n      _offset = at - base + 2;\n      return data;\n    }\n    const major = (payload[at] & 0b11100000) >> 5;\n    const minor = payload[at] & 0b00011111;\n    if (major !== majorUnstructuredByteString) {\n      throw new Error(\"unexpected major type \".concat(major, \" in indefinite string.\"));\n    }\n    if (minor === minorIndefinite) {\n      throw new Error(\"nested indefinite string.\");\n    }\n    const bytes = decodeUnstructuredByteString(at, to);\n    const length = _offset;\n    at += length;\n    for (let i = 0; i < bytes.length; ++i) {\n      vector.push(bytes[i]);\n    }\n  }\n  throw new Error(\"expected break marker.\");\n}\nfunction decodeList(at, to) {\n  const listDataLength = decodeCount(at, to);\n  const offset = _offset;\n  at += offset;\n  const base = at;\n  const list = Array(listDataLength);\n  for (let i = 0; i < listDataLength; ++i) {\n    const item = decode(at, to);\n    const itemOffset = _offset;\n    list[i] = item;\n    at += itemOffset;\n  }\n  _offset = offset + (at - base);\n  return list;\n}\nfunction decodeListIndefinite(at, to) {\n  at += 1;\n  const list = [];\n  for (const base = at; at < to;) {\n    if (payload[at] === 0b11111111) {\n      _offset = at - base + 2;\n      return list;\n    }\n    const item = decode(at, to);\n    const n = _offset;\n    at += n;\n    list.push(item);\n  }\n  throw new Error(\"expected break marker.\");\n}\nfunction decodeMap(at, to) {\n  const mapDataLength = decodeCount(at, to);\n  const offset = _offset;\n  at += offset;\n  const base = at;\n  const map = {};\n  for (let i = 0; i < mapDataLength; ++i) {\n    if (at >= to) {\n      throw new Error(\"unexpected end of map payload.\");\n    }\n    const major = (payload[at] & 0b11100000) >> 5;\n    if (major !== majorUtf8String) {\n      throw new Error(\"unexpected major type \".concat(major, \" for map key at index \").concat(at, \".\"));\n    }\n    const key = decode(at, to);\n    at += _offset;\n    const value = decode(at, to);\n    at += _offset;\n    map[key] = value;\n  }\n  _offset = offset + (at - base);\n  return map;\n}\nfunction decodeMapIndefinite(at, to) {\n  at += 1;\n  const base = at;\n  const map = {};\n  for (; at < to;) {\n    if (at >= to) {\n      throw new Error(\"unexpected end of map payload.\");\n    }\n    if (payload[at] === 0b11111111) {\n      _offset = at - base + 2;\n      return map;\n    }\n    const major = (payload[at] & 0b11100000) >> 5;\n    if (major !== majorUtf8String) {\n      throw new Error(\"unexpected major type \".concat(major, \" for map key.\"));\n    }\n    const key = decode(at, to);\n    at += _offset;\n    const value = decode(at, to);\n    at += _offset;\n    map[key] = value;\n  }\n  throw new Error(\"expected break marker.\");\n}\nfunction decodeSpecial(at, to) {\n  const minor = payload[at] & 0b00011111;\n  switch (minor) {\n    case specialTrue:\n    case specialFalse:\n      _offset = 1;\n      return minor === specialTrue;\n    case specialNull:\n      _offset = 1;\n      return null;\n    case specialUndefined:\n      _offset = 1;\n      return null;\n    case extendedFloat16:\n      if (to - at < 3) {\n        throw new Error(\"incomplete float16 at end of buf.\");\n      }\n      _offset = 3;\n      return bytesToFloat16(payload[at + 1], payload[at + 2]);\n    case extendedFloat32:\n      if (to - at < 5) {\n        throw new Error(\"incomplete float32 at end of buf.\");\n      }\n      _offset = 5;\n      return dataView.getFloat32(at + 1);\n    case extendedFloat64:\n      if (to - at < 9) {\n        throw new Error(\"incomplete float64 at end of buf.\");\n      }\n      _offset = 9;\n      return dataView.getFloat64(at + 1);\n    default:\n      throw new Error(\"unexpected minor value \".concat(minor, \".\"));\n  }\n}\nfunction castBigInt(bigInt) {\n  if (typeof bigInt === \"number\") {\n    return bigInt;\n  }\n  const num = Number(bigInt);\n  if (Number.MIN_SAFE_INTEGER <= num && num <= Number.MAX_SAFE_INTEGER) {\n    return num;\n  }\n  return bigInt;\n}","map":{"version":3,"names":["nv","toUtf8","alloc","extendedFloat16","extendedFloat32","extendedFloat64","extendedOneByte","majorList","majorMap","majorNegativeInt64","majorTag","majorUint64","majorUnstructuredByteString","majorUtf8String","minorIndefinite","specialFalse","specialNull","specialTrue","specialUndefined","tag","USE_TEXT_DECODER","TextDecoder","USE_BUFFER","Buffer","payload","dataView","DataView","buffer","byteOffset","byteLength","textDecoder","_offset","setPayload","bytes","decode","at","to","Error","major","minor","unsignedInt","offset","countLength","minorValueToArgumentLength","countOffset","concat","countIndex","getUint16","getUint32","getBigUint64","castBigInt","negativeInt","BigInt","length","decodeCount","b","start","i","decimalFraction","exponent","mantissa","normalizer","mantissaStr","repeat","Math","abs","String","numericString","sign","slice","replace","value","valueOffset","decodeUtf8StringIndefinite","decodeMapIndefinite","decodeListIndefinite","decodeUnstructuredByteStringIndefinite","decodeUtf8String","decodeMap","decodeList","decodeUnstructuredByteString","decodeSpecial","bytesToUtf8","_bytes$constructor","constructor","name","toString","subarray","demote","bigInteger","num","Number","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","console","warn","bytesToFloat16","a","fraction","scalar","exponentComponent","summation","pow","Infinity","NaN","vector","base","data","set","push","listDataLength","list","Array","item","itemOffset","n","mapDataLength","map","key","getFloat32","getFloat64","bigInt"],"sources":["/home/rcts/Email-differ/Frontend/node_modules/@smithy/core/dist-es/submodules/cbor/cbor-decode.js"],"sourcesContent":["import { nv } from \"@smithy/core/serde\";\nimport { toUtf8 } from \"@smithy/util-utf8\";\nimport { alloc, extendedFloat16, extendedFloat32, extendedFloat64, extendedOneByte, majorList, majorMap, majorNegativeInt64, majorTag, majorUint64, majorUnstructuredByteString, majorUtf8String, minorIndefinite, specialFalse, specialNull, specialTrue, specialUndefined, tag, } from \"./cbor-types\";\nconst USE_TEXT_DECODER = typeof TextDecoder !== \"undefined\";\nconst USE_BUFFER = typeof Buffer !== \"undefined\";\nlet payload = alloc(0);\nlet dataView = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);\nconst textDecoder = USE_TEXT_DECODER ? new TextDecoder() : null;\nlet _offset = 0;\nexport function setPayload(bytes) {\n    payload = bytes;\n    dataView = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);\n}\nexport function decode(at, to) {\n    if (at >= to) {\n        throw new Error(\"unexpected end of (decode) payload.\");\n    }\n    const major = (payload[at] & 0b1110_0000) >> 5;\n    const minor = payload[at] & 0b0001_1111;\n    switch (major) {\n        case majorUint64:\n        case majorNegativeInt64:\n        case majorTag:\n            let unsignedInt;\n            let offset;\n            if (minor < 24) {\n                unsignedInt = minor;\n                offset = 1;\n            }\n            else {\n                switch (minor) {\n                    case extendedOneByte:\n                    case extendedFloat16:\n                    case extendedFloat32:\n                    case extendedFloat64:\n                        const countLength = minorValueToArgumentLength[minor];\n                        const countOffset = (countLength + 1);\n                        offset = countOffset;\n                        if (to - at < countOffset) {\n                            throw new Error(`countLength ${countLength} greater than remaining buf len.`);\n                        }\n                        const countIndex = at + 1;\n                        if (countLength === 1) {\n                            unsignedInt = payload[countIndex];\n                        }\n                        else if (countLength === 2) {\n                            unsignedInt = dataView.getUint16(countIndex);\n                        }\n                        else if (countLength === 4) {\n                            unsignedInt = dataView.getUint32(countIndex);\n                        }\n                        else {\n                            unsignedInt = dataView.getBigUint64(countIndex);\n                        }\n                        break;\n                    default:\n                        throw new Error(`unexpected minor value ${minor}.`);\n                }\n            }\n            if (major === majorUint64) {\n                _offset = offset;\n                return castBigInt(unsignedInt);\n            }\n            else if (major === majorNegativeInt64) {\n                let negativeInt;\n                if (typeof unsignedInt === \"bigint\") {\n                    negativeInt = BigInt(-1) - unsignedInt;\n                }\n                else {\n                    negativeInt = -1 - unsignedInt;\n                }\n                _offset = offset;\n                return castBigInt(negativeInt);\n            }\n            else {\n                if (minor === 2 || minor === 3) {\n                    const length = decodeCount(at + offset, to);\n                    let b = BigInt(0);\n                    const start = at + offset + _offset;\n                    for (let i = start; i < start + length; ++i) {\n                        b = (b << BigInt(8)) | BigInt(payload[i]);\n                    }\n                    _offset = offset + _offset + length;\n                    return minor === 3 ? -b - BigInt(1) : b;\n                }\n                else if (minor === 4) {\n                    const decimalFraction = decode(at + offset, to);\n                    const [exponent, mantissa] = decimalFraction;\n                    const normalizer = mantissa < 0 ? -1 : 1;\n                    const mantissaStr = \"0\".repeat(Math.abs(exponent) + 1) + String(BigInt(normalizer) * BigInt(mantissa));\n                    let numericString;\n                    const sign = mantissa < 0 ? \"-\" : \"\";\n                    numericString =\n                        exponent === 0\n                            ? mantissaStr\n                            : mantissaStr.slice(0, mantissaStr.length + exponent) + \".\" + mantissaStr.slice(exponent);\n                    numericString = numericString.replace(/^0+/g, \"\");\n                    if (numericString === \"\") {\n                        numericString = \"0\";\n                    }\n                    if (numericString[0] === \".\") {\n                        numericString = \"0\" + numericString;\n                    }\n                    numericString = sign + numericString;\n                    _offset = offset + _offset;\n                    return nv(numericString);\n                }\n                else {\n                    const value = decode(at + offset, to);\n                    const valueOffset = _offset;\n                    _offset = offset + valueOffset;\n                    return tag({ tag: castBigInt(unsignedInt), value });\n                }\n            }\n        case majorUtf8String:\n        case majorMap:\n        case majorList:\n        case majorUnstructuredByteString:\n            if (minor === minorIndefinite) {\n                switch (major) {\n                    case majorUtf8String:\n                        return decodeUtf8StringIndefinite(at, to);\n                    case majorMap:\n                        return decodeMapIndefinite(at, to);\n                    case majorList:\n                        return decodeListIndefinite(at, to);\n                    case majorUnstructuredByteString:\n                        return decodeUnstructuredByteStringIndefinite(at, to);\n                }\n            }\n            else {\n                switch (major) {\n                    case majorUtf8String:\n                        return decodeUtf8String(at, to);\n                    case majorMap:\n                        return decodeMap(at, to);\n                    case majorList:\n                        return decodeList(at, to);\n                    case majorUnstructuredByteString:\n                        return decodeUnstructuredByteString(at, to);\n                }\n            }\n        default:\n            return decodeSpecial(at, to);\n    }\n}\nfunction bytesToUtf8(bytes, at, to) {\n    if (USE_BUFFER && bytes.constructor?.name === \"Buffer\") {\n        return bytes.toString(\"utf-8\", at, to);\n    }\n    if (textDecoder) {\n        return textDecoder.decode(bytes.subarray(at, to));\n    }\n    return toUtf8(bytes.subarray(at, to));\n}\nfunction demote(bigInteger) {\n    const num = Number(bigInteger);\n    if (num < Number.MIN_SAFE_INTEGER || Number.MAX_SAFE_INTEGER < num) {\n        console.warn(new Error(`@smithy/core/cbor - truncating BigInt(${bigInteger}) to ${num} with loss of precision.`));\n    }\n    return num;\n}\nconst minorValueToArgumentLength = {\n    [extendedOneByte]: 1,\n    [extendedFloat16]: 2,\n    [extendedFloat32]: 4,\n    [extendedFloat64]: 8,\n};\nexport function bytesToFloat16(a, b) {\n    const sign = a >> 7;\n    const exponent = (a & 0b0111_1100) >> 2;\n    const fraction = ((a & 0b0000_0011) << 8) | b;\n    const scalar = sign === 0 ? 1 : -1;\n    let exponentComponent;\n    let summation;\n    if (exponent === 0b00000) {\n        if (fraction === 0b00000_00000) {\n            return 0;\n        }\n        else {\n            exponentComponent = Math.pow(2, 1 - 15);\n            summation = 0;\n        }\n    }\n    else if (exponent === 0b11111) {\n        if (fraction === 0b00000_00000) {\n            return scalar * Infinity;\n        }\n        else {\n            return NaN;\n        }\n    }\n    else {\n        exponentComponent = Math.pow(2, exponent - 15);\n        summation = 1;\n    }\n    summation += fraction / 1024;\n    return scalar * (exponentComponent * summation);\n}\nfunction decodeCount(at, to) {\n    const minor = payload[at] & 0b0001_1111;\n    if (minor < 24) {\n        _offset = 1;\n        return minor;\n    }\n    if (minor === extendedOneByte ||\n        minor === extendedFloat16 ||\n        minor === extendedFloat32 ||\n        minor === extendedFloat64) {\n        const countLength = minorValueToArgumentLength[minor];\n        _offset = (countLength + 1);\n        if (to - at < _offset) {\n            throw new Error(`countLength ${countLength} greater than remaining buf len.`);\n        }\n        const countIndex = at + 1;\n        if (countLength === 1) {\n            return payload[countIndex];\n        }\n        else if (countLength === 2) {\n            return dataView.getUint16(countIndex);\n        }\n        else if (countLength === 4) {\n            return dataView.getUint32(countIndex);\n        }\n        return demote(dataView.getBigUint64(countIndex));\n    }\n    throw new Error(`unexpected minor value ${minor}.`);\n}\nfunction decodeUtf8String(at, to) {\n    const length = decodeCount(at, to);\n    const offset = _offset;\n    at += offset;\n    if (to - at < length) {\n        throw new Error(`string len ${length} greater than remaining buf len.`);\n    }\n    const value = bytesToUtf8(payload, at, at + length);\n    _offset = offset + length;\n    return value;\n}\nfunction decodeUtf8StringIndefinite(at, to) {\n    at += 1;\n    const vector = [];\n    for (const base = at; at < to;) {\n        if (payload[at] === 0b1111_1111) {\n            const data = alloc(vector.length);\n            data.set(vector, 0);\n            _offset = at - base + 2;\n            return bytesToUtf8(data, 0, data.length);\n        }\n        const major = (payload[at] & 0b1110_0000) >> 5;\n        const minor = payload[at] & 0b0001_1111;\n        if (major !== majorUtf8String) {\n            throw new Error(`unexpected major type ${major} in indefinite string.`);\n        }\n        if (minor === minorIndefinite) {\n            throw new Error(\"nested indefinite string.\");\n        }\n        const bytes = decodeUnstructuredByteString(at, to);\n        const length = _offset;\n        at += length;\n        for (let i = 0; i < bytes.length; ++i) {\n            vector.push(bytes[i]);\n        }\n    }\n    throw new Error(\"expected break marker.\");\n}\nfunction decodeUnstructuredByteString(at, to) {\n    const length = decodeCount(at, to);\n    const offset = _offset;\n    at += offset;\n    if (to - at < length) {\n        throw new Error(`unstructured byte string len ${length} greater than remaining buf len.`);\n    }\n    const value = payload.subarray(at, at + length);\n    _offset = offset + length;\n    return value;\n}\nfunction decodeUnstructuredByteStringIndefinite(at, to) {\n    at += 1;\n    const vector = [];\n    for (const base = at; at < to;) {\n        if (payload[at] === 0b1111_1111) {\n            const data = alloc(vector.length);\n            data.set(vector, 0);\n            _offset = at - base + 2;\n            return data;\n        }\n        const major = (payload[at] & 0b1110_0000) >> 5;\n        const minor = payload[at] & 0b0001_1111;\n        if (major !== majorUnstructuredByteString) {\n            throw new Error(`unexpected major type ${major} in indefinite string.`);\n        }\n        if (minor === minorIndefinite) {\n            throw new Error(\"nested indefinite string.\");\n        }\n        const bytes = decodeUnstructuredByteString(at, to);\n        const length = _offset;\n        at += length;\n        for (let i = 0; i < bytes.length; ++i) {\n            vector.push(bytes[i]);\n        }\n    }\n    throw new Error(\"expected break marker.\");\n}\nfunction decodeList(at, to) {\n    const listDataLength = decodeCount(at, to);\n    const offset = _offset;\n    at += offset;\n    const base = at;\n    const list = Array(listDataLength);\n    for (let i = 0; i < listDataLength; ++i) {\n        const item = decode(at, to);\n        const itemOffset = _offset;\n        list[i] = item;\n        at += itemOffset;\n    }\n    _offset = offset + (at - base);\n    return list;\n}\nfunction decodeListIndefinite(at, to) {\n    at += 1;\n    const list = [];\n    for (const base = at; at < to;) {\n        if (payload[at] === 0b1111_1111) {\n            _offset = at - base + 2;\n            return list;\n        }\n        const item = decode(at, to);\n        const n = _offset;\n        at += n;\n        list.push(item);\n    }\n    throw new Error(\"expected break marker.\");\n}\nfunction decodeMap(at, to) {\n    const mapDataLength = decodeCount(at, to);\n    const offset = _offset;\n    at += offset;\n    const base = at;\n    const map = {};\n    for (let i = 0; i < mapDataLength; ++i) {\n        if (at >= to) {\n            throw new Error(\"unexpected end of map payload.\");\n        }\n        const major = (payload[at] & 0b1110_0000) >> 5;\n        if (major !== majorUtf8String) {\n            throw new Error(`unexpected major type ${major} for map key at index ${at}.`);\n        }\n        const key = decode(at, to);\n        at += _offset;\n        const value = decode(at, to);\n        at += _offset;\n        map[key] = value;\n    }\n    _offset = offset + (at - base);\n    return map;\n}\nfunction decodeMapIndefinite(at, to) {\n    at += 1;\n    const base = at;\n    const map = {};\n    for (; at < to;) {\n        if (at >= to) {\n            throw new Error(\"unexpected end of map payload.\");\n        }\n        if (payload[at] === 0b1111_1111) {\n            _offset = at - base + 2;\n            return map;\n        }\n        const major = (payload[at] & 0b1110_0000) >> 5;\n        if (major !== majorUtf8String) {\n            throw new Error(`unexpected major type ${major} for map key.`);\n        }\n        const key = decode(at, to);\n        at += _offset;\n        const value = decode(at, to);\n        at += _offset;\n        map[key] = value;\n    }\n    throw new Error(\"expected break marker.\");\n}\nfunction decodeSpecial(at, to) {\n    const minor = payload[at] & 0b0001_1111;\n    switch (minor) {\n        case specialTrue:\n        case specialFalse:\n            _offset = 1;\n            return minor === specialTrue;\n        case specialNull:\n            _offset = 1;\n            return null;\n        case specialUndefined:\n            _offset = 1;\n            return null;\n        case extendedFloat16:\n            if (to - at < 3) {\n                throw new Error(\"incomplete float16 at end of buf.\");\n            }\n            _offset = 3;\n            return bytesToFloat16(payload[at + 1], payload[at + 2]);\n        case extendedFloat32:\n            if (to - at < 5) {\n                throw new Error(\"incomplete float32 at end of buf.\");\n            }\n            _offset = 5;\n            return dataView.getFloat32(at + 1);\n        case extendedFloat64:\n            if (to - at < 9) {\n                throw new Error(\"incomplete float64 at end of buf.\");\n            }\n            _offset = 9;\n            return dataView.getFloat64(at + 1);\n        default:\n            throw new Error(`unexpected minor value ${minor}.`);\n    }\n}\nfunction castBigInt(bigInt) {\n    if (typeof bigInt === \"number\") {\n        return bigInt;\n    }\n    const num = Number(bigInt);\n    if (Number.MIN_SAFE_INTEGER <= num && num <= Number.MAX_SAFE_INTEGER) {\n        return num;\n    }\n    return bigInt;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}