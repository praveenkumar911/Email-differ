{"ast":null,"code":"import _defineProperty from \"/home/rcts/Email-differ/Frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { SerdeContext } from \"@smithy/core/protocols\";\nimport { NormalizedSchema } from \"@smithy/core/schema\";\nimport { _parseEpochTimestamp, generateIdempotencyToken } from \"@smithy/core/serde\";\nimport { fromBase64 } from \"@smithy/util-base64\";\nimport { cbor } from \"./cbor\";\nimport { dateToTag } from \"./parseCborBody\";\nexport class CborCodec extends SerdeContext {\n  createSerializer() {\n    const serializer = new CborShapeSerializer();\n    serializer.setSerdeContext(this.serdeContext);\n    return serializer;\n  }\n  createDeserializer() {\n    const deserializer = new CborShapeDeserializer();\n    deserializer.setSerdeContext(this.serdeContext);\n    return deserializer;\n  }\n}\nexport class CborShapeSerializer extends SerdeContext {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"value\", void 0);\n  }\n  write(schema, value) {\n    this.value = this.serialize(schema, value);\n  }\n  serialize(schema, source) {\n    const ns = NormalizedSchema.of(schema);\n    if (source == null) {\n      if (ns.isIdempotencyToken()) {\n        return generateIdempotencyToken();\n      }\n      return source;\n    }\n    if (ns.isBlobSchema()) {\n      if (typeof source === \"string\") {\n        var _this$serdeContext$ba, _this$serdeContext;\n        return ((_this$serdeContext$ba = (_this$serdeContext = this.serdeContext) === null || _this$serdeContext === void 0 ? void 0 : _this$serdeContext.base64Decoder) !== null && _this$serdeContext$ba !== void 0 ? _this$serdeContext$ba : fromBase64)(source);\n      }\n      return source;\n    }\n    if (ns.isTimestampSchema()) {\n      if (typeof source === \"number\" || typeof source === \"bigint\") {\n        return dateToTag(new Date(Number(source) / 1000 | 0));\n      }\n      return dateToTag(source);\n    }\n    if (typeof source === \"function\" || typeof source === \"object\") {\n      const sourceObject = source;\n      if (ns.isListSchema() && Array.isArray(sourceObject)) {\n        const sparse = !!ns.getMergedTraits().sparse;\n        const newArray = [];\n        let i = 0;\n        for (const item of sourceObject) {\n          const value = this.serialize(ns.getValueSchema(), item);\n          if (value != null || sparse) {\n            newArray[i++] = value;\n          }\n        }\n        return newArray;\n      }\n      if (sourceObject instanceof Date) {\n        return dateToTag(sourceObject);\n      }\n      const newObject = {};\n      if (ns.isMapSchema()) {\n        const sparse = !!ns.getMergedTraits().sparse;\n        for (const key of Object.keys(sourceObject)) {\n          const value = this.serialize(ns.getValueSchema(), sourceObject[key]);\n          if (value != null || sparse) {\n            newObject[key] = value;\n          }\n        }\n      } else if (ns.isStructSchema()) {\n        for (const [key, memberSchema] of ns.structIterator()) {\n          const value = this.serialize(memberSchema, sourceObject[key]);\n          if (value != null) {\n            newObject[key] = value;\n          }\n        }\n        const isUnion = ns.isUnionSchema();\n        if (isUnion && Array.isArray(sourceObject.$unknown)) {\n          const [k, v] = sourceObject.$unknown;\n          newObject[k] = v;\n        }\n      } else if (ns.isDocumentSchema()) {\n        for (const key of Object.keys(sourceObject)) {\n          newObject[key] = this.serialize(ns.getValueSchema(), sourceObject[key]);\n        }\n      }\n      return newObject;\n    }\n    return source;\n  }\n  flush() {\n    const buffer = cbor.serialize(this.value);\n    this.value = undefined;\n    return buffer;\n  }\n}\nexport class CborShapeDeserializer extends SerdeContext {\n  read(schema, bytes) {\n    const data = cbor.deserialize(bytes);\n    return this.readValue(schema, data);\n  }\n  readValue(_schema, value) {\n    const ns = NormalizedSchema.of(_schema);\n    if (ns.isTimestampSchema()) {\n      if (typeof value === \"number\") {\n        return _parseEpochTimestamp(value);\n      }\n      if (typeof value === \"object\") {\n        if (value.tag === 1 && \"value\" in value) {\n          return _parseEpochTimestamp(value.value);\n        }\n      }\n    }\n    if (ns.isBlobSchema()) {\n      if (typeof value === \"string\") {\n        var _this$serdeContext$ba2, _this$serdeContext2;\n        return ((_this$serdeContext$ba2 = (_this$serdeContext2 = this.serdeContext) === null || _this$serdeContext2 === void 0 ? void 0 : _this$serdeContext2.base64Decoder) !== null && _this$serdeContext$ba2 !== void 0 ? _this$serdeContext$ba2 : fromBase64)(value);\n      }\n      return value;\n    }\n    if (typeof value === \"undefined\" || typeof value === \"boolean\" || typeof value === \"number\" || typeof value === \"string\" || typeof value === \"bigint\" || typeof value === \"symbol\") {\n      return value;\n    } else if (typeof value === \"object\") {\n      if (value === null) {\n        return null;\n      }\n      if (\"byteLength\" in value) {\n        return value;\n      }\n      if (value instanceof Date) {\n        return value;\n      }\n      if (ns.isDocumentSchema()) {\n        return value;\n      }\n      if (ns.isListSchema()) {\n        const newArray = [];\n        const memberSchema = ns.getValueSchema();\n        const sparse = !!ns.getMergedTraits().sparse;\n        for (const item of value) {\n          const itemValue = this.readValue(memberSchema, item);\n          if (itemValue != null || sparse) {\n            newArray.push(itemValue);\n          }\n        }\n        return newArray;\n      }\n      const newObject = {};\n      if (ns.isMapSchema()) {\n        const sparse = !!ns.getMergedTraits().sparse;\n        const targetSchema = ns.getValueSchema();\n        for (const key of Object.keys(value)) {\n          const itemValue = this.readValue(targetSchema, value[key]);\n          if (itemValue != null || sparse) {\n            newObject[key] = itemValue;\n          }\n        }\n      } else if (ns.isStructSchema()) {\n        var _keys;\n        const isUnion = ns.isUnionSchema();\n        let keys;\n        if (isUnion) {\n          keys = new Set(Object.keys(value).filter(k => k !== \"__type\"));\n        }\n        for (const [key, memberSchema] of ns.structIterator()) {\n          if (isUnion) {\n            keys.delete(key);\n          }\n          if (value[key] != null) {\n            newObject[key] = this.readValue(memberSchema, value[key]);\n          }\n        }\n        if (isUnion && ((_keys = keys) === null || _keys === void 0 ? void 0 : _keys.size) === 1 && Object.keys(newObject).length === 0) {\n          const k = keys.values().next().value;\n          newObject.$unknown = [k, value[k]];\n        }\n      }\n      return newObject;\n    } else {\n      return value;\n    }\n  }\n}","map":{"version":3,"names":["SerdeContext","NormalizedSchema","_parseEpochTimestamp","generateIdempotencyToken","fromBase64","cbor","dateToTag","CborCodec","createSerializer","serializer","CborShapeSerializer","setSerdeContext","serdeContext","createDeserializer","deserializer","CborShapeDeserializer","constructor","arguments","_defineProperty","write","schema","value","serialize","source","ns","of","isIdempotencyToken","isBlobSchema","_this$serdeContext$ba","_this$serdeContext","base64Decoder","isTimestampSchema","Date","Number","sourceObject","isListSchema","Array","isArray","sparse","getMergedTraits","newArray","i","item","getValueSchema","newObject","isMapSchema","key","Object","keys","isStructSchema","memberSchema","structIterator","isUnion","isUnionSchema","$unknown","k","v","isDocumentSchema","flush","buffer","undefined","read","bytes","data","deserialize","readValue","_schema","tag","_this$serdeContext$ba2","_this$serdeContext2","itemValue","push","targetSchema","_keys","Set","filter","delete","size","length","values","next"],"sources":["/home/rcts/Email-differ/Frontend/node_modules/@smithy/core/dist-es/submodules/cbor/CborCodec.js"],"sourcesContent":["import { SerdeContext } from \"@smithy/core/protocols\";\nimport { NormalizedSchema } from \"@smithy/core/schema\";\nimport { _parseEpochTimestamp, generateIdempotencyToken } from \"@smithy/core/serde\";\nimport { fromBase64 } from \"@smithy/util-base64\";\nimport { cbor } from \"./cbor\";\nimport { dateToTag } from \"./parseCborBody\";\nexport class CborCodec extends SerdeContext {\n    createSerializer() {\n        const serializer = new CborShapeSerializer();\n        serializer.setSerdeContext(this.serdeContext);\n        return serializer;\n    }\n    createDeserializer() {\n        const deserializer = new CborShapeDeserializer();\n        deserializer.setSerdeContext(this.serdeContext);\n        return deserializer;\n    }\n}\nexport class CborShapeSerializer extends SerdeContext {\n    value;\n    write(schema, value) {\n        this.value = this.serialize(schema, value);\n    }\n    serialize(schema, source) {\n        const ns = NormalizedSchema.of(schema);\n        if (source == null) {\n            if (ns.isIdempotencyToken()) {\n                return generateIdempotencyToken();\n            }\n            return source;\n        }\n        if (ns.isBlobSchema()) {\n            if (typeof source === \"string\") {\n                return (this.serdeContext?.base64Decoder ?? fromBase64)(source);\n            }\n            return source;\n        }\n        if (ns.isTimestampSchema()) {\n            if (typeof source === \"number\" || typeof source === \"bigint\") {\n                return dateToTag(new Date((Number(source) / 1000) | 0));\n            }\n            return dateToTag(source);\n        }\n        if (typeof source === \"function\" || typeof source === \"object\") {\n            const sourceObject = source;\n            if (ns.isListSchema() && Array.isArray(sourceObject)) {\n                const sparse = !!ns.getMergedTraits().sparse;\n                const newArray = [];\n                let i = 0;\n                for (const item of sourceObject) {\n                    const value = this.serialize(ns.getValueSchema(), item);\n                    if (value != null || sparse) {\n                        newArray[i++] = value;\n                    }\n                }\n                return newArray;\n            }\n            if (sourceObject instanceof Date) {\n                return dateToTag(sourceObject);\n            }\n            const newObject = {};\n            if (ns.isMapSchema()) {\n                const sparse = !!ns.getMergedTraits().sparse;\n                for (const key of Object.keys(sourceObject)) {\n                    const value = this.serialize(ns.getValueSchema(), sourceObject[key]);\n                    if (value != null || sparse) {\n                        newObject[key] = value;\n                    }\n                }\n            }\n            else if (ns.isStructSchema()) {\n                for (const [key, memberSchema] of ns.structIterator()) {\n                    const value = this.serialize(memberSchema, sourceObject[key]);\n                    if (value != null) {\n                        newObject[key] = value;\n                    }\n                }\n                const isUnion = ns.isUnionSchema();\n                if (isUnion && Array.isArray(sourceObject.$unknown)) {\n                    const [k, v] = sourceObject.$unknown;\n                    newObject[k] = v;\n                }\n            }\n            else if (ns.isDocumentSchema()) {\n                for (const key of Object.keys(sourceObject)) {\n                    newObject[key] = this.serialize(ns.getValueSchema(), sourceObject[key]);\n                }\n            }\n            return newObject;\n        }\n        return source;\n    }\n    flush() {\n        const buffer = cbor.serialize(this.value);\n        this.value = undefined;\n        return buffer;\n    }\n}\nexport class CborShapeDeserializer extends SerdeContext {\n    read(schema, bytes) {\n        const data = cbor.deserialize(bytes);\n        return this.readValue(schema, data);\n    }\n    readValue(_schema, value) {\n        const ns = NormalizedSchema.of(_schema);\n        if (ns.isTimestampSchema()) {\n            if (typeof value === \"number\") {\n                return _parseEpochTimestamp(value);\n            }\n            if (typeof value === \"object\") {\n                if (value.tag === 1 && \"value\" in value) {\n                    return _parseEpochTimestamp(value.value);\n                }\n            }\n        }\n        if (ns.isBlobSchema()) {\n            if (typeof value === \"string\") {\n                return (this.serdeContext?.base64Decoder ?? fromBase64)(value);\n            }\n            return value;\n        }\n        if (typeof value === \"undefined\" ||\n            typeof value === \"boolean\" ||\n            typeof value === \"number\" ||\n            typeof value === \"string\" ||\n            typeof value === \"bigint\" ||\n            typeof value === \"symbol\") {\n            return value;\n        }\n        else if (typeof value === \"object\") {\n            if (value === null) {\n                return null;\n            }\n            if (\"byteLength\" in value) {\n                return value;\n            }\n            if (value instanceof Date) {\n                return value;\n            }\n            if (ns.isDocumentSchema()) {\n                return value;\n            }\n            if (ns.isListSchema()) {\n                const newArray = [];\n                const memberSchema = ns.getValueSchema();\n                const sparse = !!ns.getMergedTraits().sparse;\n                for (const item of value) {\n                    const itemValue = this.readValue(memberSchema, item);\n                    if (itemValue != null || sparse) {\n                        newArray.push(itemValue);\n                    }\n                }\n                return newArray;\n            }\n            const newObject = {};\n            if (ns.isMapSchema()) {\n                const sparse = !!ns.getMergedTraits().sparse;\n                const targetSchema = ns.getValueSchema();\n                for (const key of Object.keys(value)) {\n                    const itemValue = this.readValue(targetSchema, value[key]);\n                    if (itemValue != null || sparse) {\n                        newObject[key] = itemValue;\n                    }\n                }\n            }\n            else if (ns.isStructSchema()) {\n                const isUnion = ns.isUnionSchema();\n                let keys;\n                if (isUnion) {\n                    keys = new Set(Object.keys(value).filter((k) => k !== \"__type\"));\n                }\n                for (const [key, memberSchema] of ns.structIterator()) {\n                    if (isUnion) {\n                        keys.delete(key);\n                    }\n                    if (value[key] != null) {\n                        newObject[key] = this.readValue(memberSchema, value[key]);\n                    }\n                }\n                if (isUnion && keys?.size === 1 && Object.keys(newObject).length === 0) {\n                    const k = keys.values().next().value;\n                    newObject.$unknown = [k, value[k]];\n                }\n            }\n            return newObject;\n        }\n        else {\n            return value;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}