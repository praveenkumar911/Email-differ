{"ast":null,"code":"import { getCircularReplacer } from \"./circularReplacer\";\nimport { sleep } from \"./utils/sleep\";\nimport { WaiterState } from \"./waiter\";\nconst exponentialBackoffWithJitter = (minDelay, maxDelay, attemptCeiling, attempt) => {\n  if (attempt > attemptCeiling) return maxDelay;\n  const delay = minDelay * 2 ** (attempt - 1);\n  return randomInRange(minDelay, delay);\n};\nconst randomInRange = (min, max) => min + Math.random() * (max - min);\nexport const runPolling = async (_ref, input, acceptorChecks) => {\n  let {\n    minDelay,\n    maxDelay,\n    maxWaitTime,\n    abortController,\n    client,\n    abortSignal\n  } = _ref;\n  const observedResponses = {};\n  const {\n    state,\n    reason\n  } = await acceptorChecks(client, input);\n  if (reason) {\n    const message = createMessageFromResponse(reason);\n    observedResponses[message] |= 0;\n    observedResponses[message] += 1;\n  }\n  if (state !== WaiterState.RETRY) {\n    return {\n      state,\n      reason,\n      observedResponses\n    };\n  }\n  let currentAttempt = 1;\n  const waitUntil = Date.now() + maxWaitTime * 1000;\n  const attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;\n  while (true) {\n    var _abortController$sign;\n    if (abortController !== null && abortController !== void 0 && (_abortController$sign = abortController.signal) !== null && _abortController$sign !== void 0 && _abortController$sign.aborted || abortSignal !== null && abortSignal !== void 0 && abortSignal.aborted) {\n      const message = \"AbortController signal aborted.\";\n      observedResponses[message] |= 0;\n      observedResponses[message] += 1;\n      return {\n        state: WaiterState.ABORTED,\n        observedResponses\n      };\n    }\n    const delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);\n    if (Date.now() + delay * 1000 > waitUntil) {\n      return {\n        state: WaiterState.TIMEOUT,\n        observedResponses\n      };\n    }\n    await sleep(delay);\n    const {\n      state,\n      reason\n    } = await acceptorChecks(client, input);\n    if (reason) {\n      const message = createMessageFromResponse(reason);\n      observedResponses[message] |= 0;\n      observedResponses[message] += 1;\n    }\n    if (state !== WaiterState.RETRY) {\n      return {\n        state,\n        reason,\n        observedResponses\n      };\n    }\n    currentAttempt += 1;\n  }\n};\nconst createMessageFromResponse = reason => {\n  var _reason$$metadata, _ref3, _reason$message;\n  if (reason !== null && reason !== void 0 && reason.$responseBodyText) {\n    return \"Deserialization error for body: \".concat(reason.$responseBodyText);\n  }\n  if (reason !== null && reason !== void 0 && (_reason$$metadata = reason.$metadata) !== null && _reason$$metadata !== void 0 && _reason$$metadata.httpStatusCode) {\n    if (reason.$response || reason.message) {\n      var _ref2, _reason$$response$sta;\n      return \"\".concat((_ref2 = (_reason$$response$sta = reason.$response.statusCode) !== null && _reason$$response$sta !== void 0 ? _reason$$response$sta : reason.$metadata.httpStatusCode) !== null && _ref2 !== void 0 ? _ref2 : \"Unknown\", \": \").concat(reason.message);\n    }\n    return \"\".concat(reason.$metadata.httpStatusCode, \": OK\");\n  }\n  return String((_ref3 = (_reason$message = reason === null || reason === void 0 ? void 0 : reason.message) !== null && _reason$message !== void 0 ? _reason$message : JSON.stringify(reason, getCircularReplacer())) !== null && _ref3 !== void 0 ? _ref3 : \"Unknown\");\n};","map":{"version":3,"names":["getCircularReplacer","sleep","WaiterState","exponentialBackoffWithJitter","minDelay","maxDelay","attemptCeiling","attempt","delay","randomInRange","min","max","Math","random","runPolling","_ref","input","acceptorChecks","maxWaitTime","abortController","client","abortSignal","observedResponses","state","reason","message","createMessageFromResponse","RETRY","currentAttempt","waitUntil","Date","now","log","_abortController$sign","signal","aborted","ABORTED","TIMEOUT","_reason$$metadata","_ref3","_reason$message","$responseBodyText","concat","$metadata","httpStatusCode","$response","_ref2","_reason$$response$sta","statusCode","String","JSON","stringify"],"sources":["/home/rcts/Email-differ/Frontend/node_modules/@smithy/util-waiter/dist-es/poller.js"],"sourcesContent":["import { getCircularReplacer } from \"./circularReplacer\";\nimport { sleep } from \"./utils/sleep\";\nimport { WaiterState } from \"./waiter\";\nconst exponentialBackoffWithJitter = (minDelay, maxDelay, attemptCeiling, attempt) => {\n    if (attempt > attemptCeiling)\n        return maxDelay;\n    const delay = minDelay * 2 ** (attempt - 1);\n    return randomInRange(minDelay, delay);\n};\nconst randomInRange = (min, max) => min + Math.random() * (max - min);\nexport const runPolling = async ({ minDelay, maxDelay, maxWaitTime, abortController, client, abortSignal }, input, acceptorChecks) => {\n    const observedResponses = {};\n    const { state, reason } = await acceptorChecks(client, input);\n    if (reason) {\n        const message = createMessageFromResponse(reason);\n        observedResponses[message] |= 0;\n        observedResponses[message] += 1;\n    }\n    if (state !== WaiterState.RETRY) {\n        return { state, reason, observedResponses };\n    }\n    let currentAttempt = 1;\n    const waitUntil = Date.now() + maxWaitTime * 1000;\n    const attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;\n    while (true) {\n        if (abortController?.signal?.aborted || abortSignal?.aborted) {\n            const message = \"AbortController signal aborted.\";\n            observedResponses[message] |= 0;\n            observedResponses[message] += 1;\n            return { state: WaiterState.ABORTED, observedResponses };\n        }\n        const delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);\n        if (Date.now() + delay * 1000 > waitUntil) {\n            return { state: WaiterState.TIMEOUT, observedResponses };\n        }\n        await sleep(delay);\n        const { state, reason } = await acceptorChecks(client, input);\n        if (reason) {\n            const message = createMessageFromResponse(reason);\n            observedResponses[message] |= 0;\n            observedResponses[message] += 1;\n        }\n        if (state !== WaiterState.RETRY) {\n            return { state, reason, observedResponses };\n        }\n        currentAttempt += 1;\n    }\n};\nconst createMessageFromResponse = (reason) => {\n    if (reason?.$responseBodyText) {\n        return `Deserialization error for body: ${reason.$responseBodyText}`;\n    }\n    if (reason?.$metadata?.httpStatusCode) {\n        if (reason.$response || reason.message) {\n            return `${reason.$response.statusCode ?? reason.$metadata.httpStatusCode ?? \"Unknown\"}: ${reason.message}`;\n        }\n        return `${reason.$metadata.httpStatusCode}: OK`;\n    }\n    return String(reason?.message ?? JSON.stringify(reason, getCircularReplacer()) ?? \"Unknown\");\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}