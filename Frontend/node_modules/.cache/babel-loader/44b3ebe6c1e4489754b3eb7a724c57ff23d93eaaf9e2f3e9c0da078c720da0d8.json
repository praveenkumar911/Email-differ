{"ast":null,"code":"import _defineProperty from \"/home/rcts/Email-differ/Frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { parseXML } from \"@aws-sdk/xml-builder\";\nimport { FromStringShapeDeserializer } from \"@smithy/core/protocols\";\nimport { NormalizedSchema } from \"@smithy/core/schema\";\nimport { getValueFromTextNode } from \"@smithy/smithy-client\";\nimport { toUtf8 } from \"@smithy/util-utf8\";\nimport { SerdeContextConfig } from \"../ConfigurableSerdeContext\";\nimport { UnionSerde } from \"../UnionSerde\";\nexport class XmlShapeDeserializer extends SerdeContextConfig {\n  constructor(settings) {\n    super();\n    _defineProperty(this, \"settings\", void 0);\n    _defineProperty(this, \"stringDeserializer\", void 0);\n    this.settings = settings;\n    this.stringDeserializer = new FromStringShapeDeserializer(settings);\n  }\n  setSerdeContext(serdeContext) {\n    this.serdeContext = serdeContext;\n    this.stringDeserializer.setSerdeContext(serdeContext);\n  }\n  read(schema, bytes, key) {\n    var _this$serdeContext$ut, _this$serdeContext;\n    const ns = NormalizedSchema.of(schema);\n    const memberSchemas = ns.getMemberSchemas();\n    const isEventPayload = ns.isStructSchema() && ns.isMemberSchema() && !!Object.values(memberSchemas).find(memberNs => {\n      return !!memberNs.getMemberTraits().eventPayload;\n    });\n    if (isEventPayload) {\n      const output = {};\n      const memberName = Object.keys(memberSchemas)[0];\n      const eventMemberSchema = memberSchemas[memberName];\n      if (eventMemberSchema.isBlobSchema()) {\n        output[memberName] = bytes;\n      } else {\n        output[memberName] = this.read(memberSchemas[memberName], bytes);\n      }\n      return output;\n    }\n    const xmlString = ((_this$serdeContext$ut = (_this$serdeContext = this.serdeContext) === null || _this$serdeContext === void 0 ? void 0 : _this$serdeContext.utf8Encoder) !== null && _this$serdeContext$ut !== void 0 ? _this$serdeContext$ut : toUtf8)(bytes);\n    const parsedObject = this.parseXml(xmlString);\n    return this.readSchema(schema, key ? parsedObject[key] : parsedObject);\n  }\n  readSchema(_schema, value) {\n    const ns = NormalizedSchema.of(_schema);\n    if (ns.isUnitSchema()) {\n      return;\n    }\n    const traits = ns.getMergedTraits();\n    if (ns.isListSchema() && !Array.isArray(value)) {\n      return this.readSchema(ns, [value]);\n    }\n    if (value == null) {\n      return value;\n    }\n    if (typeof value === \"object\") {\n      const sparse = !!traits.sparse;\n      const flat = !!traits.xmlFlattened;\n      if (ns.isListSchema()) {\n        var _listValue$getMergedT, _value$;\n        const listValue = ns.getValueSchema();\n        const buffer = [];\n        const sourceKey = (_listValue$getMergedT = listValue.getMergedTraits().xmlName) !== null && _listValue$getMergedT !== void 0 ? _listValue$getMergedT : \"member\";\n        const source = flat ? value : ((_value$ = value[0]) !== null && _value$ !== void 0 ? _value$ : value)[sourceKey];\n        const sourceArray = Array.isArray(source) ? source : [source];\n        for (const v of sourceArray) {\n          if (v != null || sparse) {\n            buffer.push(this.readSchema(listValue, v));\n          }\n        }\n        return buffer;\n      }\n      const buffer = {};\n      if (ns.isMapSchema()) {\n        var _keyNs$getMergedTrait, _memberNs$getMergedTr;\n        const keyNs = ns.getKeySchema();\n        const memberNs = ns.getValueSchema();\n        let entries;\n        if (flat) {\n          entries = Array.isArray(value) ? value : [value];\n        } else {\n          entries = Array.isArray(value.entry) ? value.entry : [value.entry];\n        }\n        const keyProperty = (_keyNs$getMergedTrait = keyNs.getMergedTraits().xmlName) !== null && _keyNs$getMergedTrait !== void 0 ? _keyNs$getMergedTrait : \"key\";\n        const valueProperty = (_memberNs$getMergedTr = memberNs.getMergedTraits().xmlName) !== null && _memberNs$getMergedTr !== void 0 ? _memberNs$getMergedTr : \"value\";\n        for (const entry of entries) {\n          const key = entry[keyProperty];\n          const value = entry[valueProperty];\n          if (value != null || sparse) {\n            buffer[key] = this.readSchema(memberNs, value);\n          }\n        }\n        return buffer;\n      }\n      if (ns.isStructSchema()) {\n        const union = ns.isUnionSchema();\n        let unionSerde;\n        if (union) {\n          unionSerde = new UnionSerde(value, buffer);\n        }\n        for (const [memberName, memberSchema] of ns.structIterator()) {\n          var _memberSchema$getMemb, _memberTraits$xmlName;\n          const memberTraits = memberSchema.getMergedTraits();\n          const xmlObjectKey = !memberTraits.httpPayload ? (_memberSchema$getMemb = memberSchema.getMemberTraits().xmlName) !== null && _memberSchema$getMemb !== void 0 ? _memberSchema$getMemb : memberName : (_memberTraits$xmlName = memberTraits.xmlName) !== null && _memberTraits$xmlName !== void 0 ? _memberTraits$xmlName : memberSchema.getName();\n          if (union) {\n            unionSerde.mark(xmlObjectKey);\n          }\n          if (value[xmlObjectKey] != null) {\n            buffer[memberName] = this.readSchema(memberSchema, value[xmlObjectKey]);\n          }\n        }\n        if (union) {\n          unionSerde.writeUnknown();\n        }\n        return buffer;\n      }\n      if (ns.isDocumentSchema()) {\n        return value;\n      }\n      throw new Error(\"@aws-sdk/core/protocols - xml deserializer unhandled schema type for \".concat(ns.getName(true)));\n    }\n    if (ns.isListSchema()) {\n      return [];\n    }\n    if (ns.isMapSchema() || ns.isStructSchema()) {\n      return {};\n    }\n    return this.stringDeserializer.read(ns, value);\n  }\n  parseXml(xml) {\n    if (xml.length) {\n      let parsedObj;\n      try {\n        parsedObj = parseXML(xml);\n      } catch (e) {\n        if (e && typeof e === \"object\") {\n          Object.defineProperty(e, \"$responseBodyText\", {\n            value: xml\n          });\n        }\n        throw e;\n      }\n      const textNodeName = \"#text\";\n      const key = Object.keys(parsedObj)[0];\n      const parsedObjToReturn = parsedObj[key];\n      if (parsedObjToReturn[textNodeName]) {\n        parsedObjToReturn[key] = parsedObjToReturn[textNodeName];\n        delete parsedObjToReturn[textNodeName];\n      }\n      return getValueFromTextNode(parsedObjToReturn);\n    }\n    return {};\n  }\n}","map":{"version":3,"names":["parseXML","FromStringShapeDeserializer","NormalizedSchema","getValueFromTextNode","toUtf8","SerdeContextConfig","UnionSerde","XmlShapeDeserializer","constructor","settings","_defineProperty","stringDeserializer","setSerdeContext","serdeContext","read","schema","bytes","key","_this$serdeContext$ut","_this$serdeContext","ns","of","memberSchemas","getMemberSchemas","isEventPayload","isStructSchema","isMemberSchema","Object","values","find","memberNs","getMemberTraits","eventPayload","output","memberName","keys","eventMemberSchema","isBlobSchema","xmlString","utf8Encoder","parsedObject","parseXml","readSchema","_schema","value","isUnitSchema","traits","getMergedTraits","isListSchema","Array","isArray","sparse","flat","xmlFlattened","_listValue$getMergedT","_value$","listValue","getValueSchema","buffer","sourceKey","xmlName","source","sourceArray","v","push","isMapSchema","_keyNs$getMergedTrait","_memberNs$getMergedTr","keyNs","getKeySchema","entries","entry","keyProperty","valueProperty","union","isUnionSchema","unionSerde","memberSchema","structIterator","_memberSchema$getMemb","_memberTraits$xmlName","memberTraits","xmlObjectKey","httpPayload","getName","mark","writeUnknown","isDocumentSchema","Error","concat","xml","length","parsedObj","e","defineProperty","textNodeName","parsedObjToReturn"],"sources":["/home/rcts/Email-differ/Frontend/node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlShapeDeserializer.js"],"sourcesContent":["import { parseXML } from \"@aws-sdk/xml-builder\";\nimport { FromStringShapeDeserializer } from \"@smithy/core/protocols\";\nimport { NormalizedSchema } from \"@smithy/core/schema\";\nimport { getValueFromTextNode } from \"@smithy/smithy-client\";\nimport { toUtf8 } from \"@smithy/util-utf8\";\nimport { SerdeContextConfig } from \"../ConfigurableSerdeContext\";\nimport { UnionSerde } from \"../UnionSerde\";\nexport class XmlShapeDeserializer extends SerdeContextConfig {\n    settings;\n    stringDeserializer;\n    constructor(settings) {\n        super();\n        this.settings = settings;\n        this.stringDeserializer = new FromStringShapeDeserializer(settings);\n    }\n    setSerdeContext(serdeContext) {\n        this.serdeContext = serdeContext;\n        this.stringDeserializer.setSerdeContext(serdeContext);\n    }\n    read(schema, bytes, key) {\n        const ns = NormalizedSchema.of(schema);\n        const memberSchemas = ns.getMemberSchemas();\n        const isEventPayload = ns.isStructSchema() &&\n            ns.isMemberSchema() &&\n            !!Object.values(memberSchemas).find((memberNs) => {\n                return !!memberNs.getMemberTraits().eventPayload;\n            });\n        if (isEventPayload) {\n            const output = {};\n            const memberName = Object.keys(memberSchemas)[0];\n            const eventMemberSchema = memberSchemas[memberName];\n            if (eventMemberSchema.isBlobSchema()) {\n                output[memberName] = bytes;\n            }\n            else {\n                output[memberName] = this.read(memberSchemas[memberName], bytes);\n            }\n            return output;\n        }\n        const xmlString = (this.serdeContext?.utf8Encoder ?? toUtf8)(bytes);\n        const parsedObject = this.parseXml(xmlString);\n        return this.readSchema(schema, key ? parsedObject[key] : parsedObject);\n    }\n    readSchema(_schema, value) {\n        const ns = NormalizedSchema.of(_schema);\n        if (ns.isUnitSchema()) {\n            return;\n        }\n        const traits = ns.getMergedTraits();\n        if (ns.isListSchema() && !Array.isArray(value)) {\n            return this.readSchema(ns, [value]);\n        }\n        if (value == null) {\n            return value;\n        }\n        if (typeof value === \"object\") {\n            const sparse = !!traits.sparse;\n            const flat = !!traits.xmlFlattened;\n            if (ns.isListSchema()) {\n                const listValue = ns.getValueSchema();\n                const buffer = [];\n                const sourceKey = listValue.getMergedTraits().xmlName ?? \"member\";\n                const source = flat ? value : (value[0] ?? value)[sourceKey];\n                const sourceArray = Array.isArray(source) ? source : [source];\n                for (const v of sourceArray) {\n                    if (v != null || sparse) {\n                        buffer.push(this.readSchema(listValue, v));\n                    }\n                }\n                return buffer;\n            }\n            const buffer = {};\n            if (ns.isMapSchema()) {\n                const keyNs = ns.getKeySchema();\n                const memberNs = ns.getValueSchema();\n                let entries;\n                if (flat) {\n                    entries = Array.isArray(value) ? value : [value];\n                }\n                else {\n                    entries = Array.isArray(value.entry) ? value.entry : [value.entry];\n                }\n                const keyProperty = keyNs.getMergedTraits().xmlName ?? \"key\";\n                const valueProperty = memberNs.getMergedTraits().xmlName ?? \"value\";\n                for (const entry of entries) {\n                    const key = entry[keyProperty];\n                    const value = entry[valueProperty];\n                    if (value != null || sparse) {\n                        buffer[key] = this.readSchema(memberNs, value);\n                    }\n                }\n                return buffer;\n            }\n            if (ns.isStructSchema()) {\n                const union = ns.isUnionSchema();\n                let unionSerde;\n                if (union) {\n                    unionSerde = new UnionSerde(value, buffer);\n                }\n                for (const [memberName, memberSchema] of ns.structIterator()) {\n                    const memberTraits = memberSchema.getMergedTraits();\n                    const xmlObjectKey = !memberTraits.httpPayload\n                        ? memberSchema.getMemberTraits().xmlName ?? memberName\n                        : memberTraits.xmlName ?? memberSchema.getName();\n                    if (union) {\n                        unionSerde.mark(xmlObjectKey);\n                    }\n                    if (value[xmlObjectKey] != null) {\n                        buffer[memberName] = this.readSchema(memberSchema, value[xmlObjectKey]);\n                    }\n                }\n                if (union) {\n                    unionSerde.writeUnknown();\n                }\n                return buffer;\n            }\n            if (ns.isDocumentSchema()) {\n                return value;\n            }\n            throw new Error(`@aws-sdk/core/protocols - xml deserializer unhandled schema type for ${ns.getName(true)}`);\n        }\n        if (ns.isListSchema()) {\n            return [];\n        }\n        if (ns.isMapSchema() || ns.isStructSchema()) {\n            return {};\n        }\n        return this.stringDeserializer.read(ns, value);\n    }\n    parseXml(xml) {\n        if (xml.length) {\n            let parsedObj;\n            try {\n                parsedObj = parseXML(xml);\n            }\n            catch (e) {\n                if (e && typeof e === \"object\") {\n                    Object.defineProperty(e, \"$responseBodyText\", {\n                        value: xml,\n                    });\n                }\n                throw e;\n            }\n            const textNodeName = \"#text\";\n            const key = Object.keys(parsedObj)[0];\n            const parsedObjToReturn = parsedObj[key];\n            if (parsedObjToReturn[textNodeName]) {\n                parsedObjToReturn[key] = parsedObjToReturn[textNodeName];\n                delete parsedObjToReturn[textNodeName];\n            }\n            return getValueFromTextNode(parsedObjToReturn);\n        }\n        return {};\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}