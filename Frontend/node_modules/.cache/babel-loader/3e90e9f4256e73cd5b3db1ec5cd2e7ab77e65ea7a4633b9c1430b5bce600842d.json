{"ast":null,"code":"function _createForOfIteratorHelperLoose(r, e) {\n  var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (t) return (t = t.call(r)).next.bind(t);\n  if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) {\n    t && (r = t);\n    var o = 0;\n    return function () {\n      return o >= r.length ? {\n        done: !0\n      } : {\n        done: !1,\n        value: r[o++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport PatternParser from './AsYouTypeFormatter.PatternParser.js';\nvar PatternMatcher = /*#__PURE__*/function () {\n  function PatternMatcher(pattern) {\n    _classCallCheck(this, PatternMatcher);\n    this.matchTree = new PatternParser().parse(pattern);\n  }\n  return _createClass(PatternMatcher, [{\n    key: \"match\",\n    value: function match(string) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        allowOverflow = _ref.allowOverflow;\n      if (!string) {\n        throw new Error('String is required');\n      }\n      var result = _match(string.split(''), this.matchTree, true);\n      if (result && result.match) {\n        delete result.matchedChars;\n      }\n      if (result && result.overflow) {\n        if (!allowOverflow) {\n          return;\n        }\n      }\n      return result;\n    }\n  }]);\n}();\n/**\r\n * Matches `characters` against a pattern compiled into a `tree`.\r\n * @param  {string[]} characters\r\n * @param  {Tree} tree — A pattern compiled into a `tree`. See the `*.d.ts` file for the description of the `tree` structure.\r\n * @param  {boolean} last — Whether it's the last (rightmost) subtree on its level of the match tree.\r\n * @return {object} See the `*.d.ts` file for the description of the result object.\r\n */\nexport { PatternMatcher as default };\nfunction _match(characters, tree, last) {\n  // If `tree` is a string, then `tree` is a single character.\n  // That's because when a pattern is parsed, multi-character-string parts\n  // of a pattern are compiled into arrays of single characters.\n  // I still wrote this piece of code for a \"general\" hypothetical case\n  // when `tree` could be a string of several characters, even though\n  // such case is not possible with the current implementation.\n  if (typeof tree === 'string') {\n    var characterString = characters.join('');\n    if (tree.indexOf(characterString) === 0) {\n      // `tree` is always a single character.\n      // If `tree.indexOf(characterString) === 0`\n      // then `characters.length === tree.length`.\n      /* istanbul ignore else */\n      if (characters.length === tree.length) {\n        return {\n          match: true,\n          matchedChars: characters\n        };\n      }\n      // `tree` is always a single character.\n      // If `tree.indexOf(characterString) === 0`\n      // then `characters.length === tree.length`.\n      /* istanbul ignore next */\n      return {\n        partialMatch: true\n        // matchedChars: characters\n      };\n    }\n    if (characterString.indexOf(tree) === 0) {\n      if (last) {\n        // The `else` path is not possible because `tree` is always a single character.\n        // The `else` case for `characters.length > tree.length` would be\n        // `characters.length <= tree.length` which means `characters.length <= 1`.\n        // `characters` array can't be empty, so that means `characters === [tree]`,\n        // which would also mean `tree.indexOf(characterString) === 0` and that'd mean\n        // that the `if (tree.indexOf(characterString) === 0)` condition before this\n        // `if` condition would be entered, and returned from there, not reaching this code.\n        /* istanbul ignore else */\n        if (characters.length > tree.length) {\n          return {\n            overflow: true\n          };\n        }\n      }\n      return {\n        match: true,\n        matchedChars: characters.slice(0, tree.length)\n      };\n    }\n    return;\n  }\n  if (Array.isArray(tree)) {\n    var restCharacters = characters.slice();\n    var i = 0;\n    while (i < tree.length) {\n      var subtree = tree[i];\n      var result = _match(restCharacters, subtree, last && i === tree.length - 1);\n      if (!result) {\n        return;\n      } else if (result.overflow) {\n        return result;\n      } else if (result.match) {\n        // Continue with the next subtree with the rest of the characters.\n        restCharacters = restCharacters.slice(result.matchedChars.length);\n        if (restCharacters.length === 0) {\n          if (i === tree.length - 1) {\n            return {\n              match: true,\n              matchedChars: characters\n            };\n          } else {\n            return {\n              partialMatch: true\n              // matchedChars: characters\n            };\n          }\n        }\n      } else {\n        /* istanbul ignore else */\n        if (result.partialMatch) {\n          return {\n            partialMatch: true\n            // matchedChars: characters\n          };\n        } else {\n          throw new Error(\"Unsupported match result:\\n\".concat(JSON.stringify(result, null, 2)));\n        }\n      }\n      i++;\n    }\n    // If `last` then overflow has already been checked\n    // by the last element of the `tree` array.\n    /* istanbul ignore if */\n    if (last) {\n      return {\n        overflow: true\n      };\n    }\n    return {\n      match: true,\n      matchedChars: characters.slice(0, characters.length - restCharacters.length)\n    };\n  }\n  switch (tree.op) {\n    case '|':\n      var partialMatch;\n      for (var _iterator = _createForOfIteratorHelperLoose(tree.args), _step; !(_step = _iterator()).done;) {\n        var branch = _step.value;\n        var _result = _match(characters, branch, last);\n        if (_result) {\n          if (_result.overflow) {\n            return _result;\n          } else if (_result.match) {\n            return {\n              match: true,\n              matchedChars: _result.matchedChars\n            };\n          } else {\n            /* istanbul ignore else */\n            if (_result.partialMatch) {\n              partialMatch = true;\n            } else {\n              throw new Error(\"Unsupported match result:\\n\".concat(JSON.stringify(_result, null, 2)));\n            }\n          }\n        }\n      }\n      if (partialMatch) {\n        return {\n          partialMatch: true\n          // matchedChars: ...\n        };\n      }\n      // Not even a partial match.\n      return;\n    case '[]':\n      for (var _iterator2 = _createForOfIteratorHelperLoose(tree.args), _step2; !(_step2 = _iterator2()).done;) {\n        var _char = _step2.value;\n        if (characters[0] === _char) {\n          if (characters.length === 1) {\n            return {\n              match: true,\n              matchedChars: characters\n            };\n          }\n          if (last) {\n            return {\n              overflow: true\n            };\n          }\n          return {\n            match: true,\n            matchedChars: [_char]\n          };\n        }\n      }\n      // No character matches.\n      return;\n\n    /* istanbul ignore next */\n    default:\n      throw new Error(\"Unsupported instruction tree: \".concat(tree));\n  }\n}","map":{"version":3,"names":["PatternParser","PatternMatcher","pattern","_classCallCheck","matchTree","parse","_createClass","key","value","match","string","_ref","arguments","length","undefined","allowOverflow","Error","result","_match","split","matchedChars","overflow","default","characters","tree","last","characterString","join","indexOf","partialMatch","slice","Array","isArray","restCharacters","i","subtree","concat","JSON","stringify","op","_iterator","_createForOfIteratorHelperLoose","args","_step","done","branch","_result","_iterator2","_step2","_char"],"sources":["/home/rcts/Email-differ/Frontend/node_modules/libphonenumber-js/source/AsYouTypeFormatter.PatternMatcher.js"],"sourcesContent":["import PatternParser from './AsYouTypeFormatter.PatternParser.js'\r\n\r\nexport default class PatternMatcher {\r\n\tconstructor(pattern) {\r\n\t\tthis.matchTree = new PatternParser().parse(pattern)\r\n\t}\r\n\r\n\tmatch(string, { allowOverflow } = {}) {\r\n\t\tif (!string) {\r\n\t\t\tthrow new Error('String is required')\r\n\t\t}\r\n\t\tconst result = match(string.split(''), this.matchTree, true)\r\n\t\tif (result && result.match) {\r\n\t\t\tdelete result.matchedChars\r\n\t\t}\r\n\t\tif (result && result.overflow) {\r\n\t\t\tif (!allowOverflow) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result\r\n\t}\r\n}\r\n\r\n/**\r\n * Matches `characters` against a pattern compiled into a `tree`.\r\n * @param  {string[]} characters\r\n * @param  {Tree} tree — A pattern compiled into a `tree`. See the `*.d.ts` file for the description of the `tree` structure.\r\n * @param  {boolean} last — Whether it's the last (rightmost) subtree on its level of the match tree.\r\n * @return {object} See the `*.d.ts` file for the description of the result object.\r\n */\r\nfunction match(characters, tree, last) {\r\n\t// If `tree` is a string, then `tree` is a single character.\r\n\t// That's because when a pattern is parsed, multi-character-string parts\r\n\t// of a pattern are compiled into arrays of single characters.\r\n\t// I still wrote this piece of code for a \"general\" hypothetical case\r\n\t// when `tree` could be a string of several characters, even though\r\n\t// such case is not possible with the current implementation.\r\n\tif (typeof tree === 'string') {\r\n\t\tconst characterString = characters.join('')\r\n\t\tif (tree.indexOf(characterString) === 0) {\r\n\t\t\t// `tree` is always a single character.\r\n\t\t\t// If `tree.indexOf(characterString) === 0`\r\n\t\t\t// then `characters.length === tree.length`.\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif (characters.length === tree.length) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tmatch: true,\r\n\t\t\t\t\tmatchedChars: characters\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// `tree` is always a single character.\r\n\t\t\t// If `tree.indexOf(characterString) === 0`\r\n\t\t\t// then `characters.length === tree.length`.\r\n\t\t\t/* istanbul ignore next */\r\n\t\t\treturn {\r\n\t\t\t\tpartialMatch: true,\r\n\t\t\t\t// matchedChars: characters\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (characterString.indexOf(tree) === 0) {\r\n\t\t\tif (last) {\r\n\t\t\t\t// The `else` path is not possible because `tree` is always a single character.\r\n\t\t\t\t// The `else` case for `characters.length > tree.length` would be\r\n\t\t\t\t// `characters.length <= tree.length` which means `characters.length <= 1`.\r\n\t\t\t\t// `characters` array can't be empty, so that means `characters === [tree]`,\r\n\t\t\t\t// which would also mean `tree.indexOf(characterString) === 0` and that'd mean\r\n\t\t\t\t// that the `if (tree.indexOf(characterString) === 0)` condition before this\r\n\t\t\t\t// `if` condition would be entered, and returned from there, not reaching this code.\r\n\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\tif (characters.length > tree.length) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\toverflow: true\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\tmatch: true,\r\n\t\t\t\tmatchedChars: characters.slice(0, tree.length)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\r\n\tif (Array.isArray(tree)) {\r\n\t\tlet restCharacters = characters.slice()\r\n\t\tlet i = 0\r\n\t\twhile (i < tree.length) {\r\n\t\t\tconst subtree = tree[i]\r\n\t\t\tconst result = match(restCharacters, subtree, last && (i === tree.length - 1))\r\n\t\t\tif (!result) {\r\n\t\t\t\treturn\r\n\t\t\t} else if (result.overflow) {\r\n\t\t\t\treturn result\r\n\t\t\t} else if (result.match) {\r\n\t\t\t\t// Continue with the next subtree with the rest of the characters.\r\n\t\t\t\trestCharacters = restCharacters.slice(result.matchedChars.length)\r\n\t\t\t\tif (restCharacters.length === 0) {\r\n\t\t\t\t\tif (i === tree.length - 1) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\t\tmatchedChars: characters\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tpartialMatch: true,\r\n\t\t\t\t\t\t\t// matchedChars: characters\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\tif (result.partialMatch) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tpartialMatch: true,\r\n\t\t\t\t\t\t// matchedChars: characters\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(`Unsupported match result:\\n${JSON.stringify(result, null, 2)}`)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ti++\r\n\t\t}\r\n\t\t// If `last` then overflow has already been checked\r\n\t\t// by the last element of the `tree` array.\r\n\t\t/* istanbul ignore if */\r\n\t\tif (last) {\r\n\t\t\treturn {\r\n\t\t\t\toverflow: true\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tmatch: true,\r\n\t\t\tmatchedChars: characters.slice(0, characters.length - restCharacters.length)\r\n\t\t}\r\n\t}\r\n\r\n\tswitch (tree.op) {\r\n\t\tcase '|':\r\n\t\t\tlet partialMatch\r\n\t\t\tfor (const branch of tree.args) {\r\n\t\t\t\tconst result = match(characters, branch, last)\r\n\t\t\t\tif (result) {\r\n\t\t\t\t\tif (result.overflow) {\r\n\t\t\t\t\t\treturn result\r\n\t\t\t\t\t} else if (result.match) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\t\tmatchedChars: result.matchedChars\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\t\t\tif (result.partialMatch) {\r\n\t\t\t\t\t\t\tpartialMatch = true\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthrow new Error(`Unsupported match result:\\n${JSON.stringify(result, null, 2)}`)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (partialMatch) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tpartialMatch: true,\r\n\t\t\t\t\t// matchedChars: ...\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Not even a partial match.\r\n\t\t\treturn\r\n\r\n\t\tcase '[]':\r\n\t\t\tfor (const char of tree.args) {\r\n\t\t\t\tif (characters[0] === char) {\r\n\t\t\t\t\tif (characters.length === 1) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\t\tmatchedChars: characters\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (last) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\toverflow: true\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\tmatchedChars: [char]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// No character matches.\r\n\t\t\treturn\r\n\r\n\t\t/* istanbul ignore next */\r\n\t\tdefault:\r\n\t\t\tthrow new Error(`Unsupported instruction tree: ${tree}`)\r\n\t}\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}