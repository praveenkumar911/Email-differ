{"ast":null,"code":"import _objectSpread from \"/home/rcts/Email-differ/Frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { NormalizedSchema, translateTraits } from \"@smithy/core/schema\";\nimport { splitEvery, splitHeader } from \"@smithy/core/serde\";\nimport { HttpRequest } from \"@smithy/protocol-http\";\nimport { sdkStreamMixin } from \"@smithy/util-stream\";\nimport { collectBody } from \"./collect-stream-body\";\nimport { extendedEncodeURIComponent } from \"./extended-encode-uri-component\";\nimport { HttpProtocol } from \"./HttpProtocol\";\nexport class HttpBindingProtocol extends HttpProtocol {\n  async serializeRequest(operationSchema, _input, context) {\n    const input = _objectSpread({}, _input !== null && _input !== void 0 ? _input : {});\n    const serializer = this.serializer;\n    const query = {};\n    const headers = {};\n    const endpoint = await context.endpoint();\n    const ns = NormalizedSchema.of(operationSchema === null || operationSchema === void 0 ? void 0 : operationSchema.input);\n    const schema = ns.getSchema();\n    let hasNonHttpBindingMember = false;\n    let payload;\n    const request = new HttpRequest({\n      protocol: \"\",\n      hostname: \"\",\n      port: undefined,\n      path: \"\",\n      fragment: undefined,\n      query: query,\n      headers: headers,\n      body: undefined\n    });\n    if (endpoint) {\n      this.updateServiceEndpoint(request, endpoint);\n      this.setHostPrefix(request, operationSchema, input);\n      const opTraits = translateTraits(operationSchema.traits);\n      if (opTraits.http) {\n        request.method = opTraits.http[0];\n        const [path, search] = opTraits.http[1].split(\"?\");\n        if (request.path == \"/\") {\n          request.path = path;\n        } else {\n          request.path += path;\n        }\n        const traitSearchParams = new URLSearchParams(search !== null && search !== void 0 ? search : \"\");\n        Object.assign(query, Object.fromEntries(traitSearchParams));\n      }\n    }\n    for (const [memberName, memberNs] of ns.structIterator()) {\n      var _memberNs$getMergedTr;\n      const memberTraits = (_memberNs$getMergedTr = memberNs.getMergedTraits()) !== null && _memberNs$getMergedTr !== void 0 ? _memberNs$getMergedTr : {};\n      const inputMemberValue = input[memberName];\n      if (inputMemberValue == null && !memberNs.isIdempotencyToken()) {\n        continue;\n      }\n      if (memberTraits.httpPayload) {\n        const isStreaming = memberNs.isStreaming();\n        if (isStreaming) {\n          const isEventStream = memberNs.isStructSchema();\n          if (isEventStream) {\n            if (input[memberName]) {\n              payload = await this.serializeEventStream({\n                eventStream: input[memberName],\n                requestSchema: ns\n              });\n            }\n          } else {\n            payload = inputMemberValue;\n          }\n        } else {\n          serializer.write(memberNs, inputMemberValue);\n          payload = serializer.flush();\n        }\n        delete input[memberName];\n      } else if (memberTraits.httpLabel) {\n        serializer.write(memberNs, inputMemberValue);\n        const replacement = serializer.flush();\n        if (request.path.includes(\"{\".concat(memberName, \"+}\"))) {\n          request.path = request.path.replace(\"{\".concat(memberName, \"+}\"), replacement.split(\"/\").map(extendedEncodeURIComponent).join(\"/\"));\n        } else if (request.path.includes(\"{\".concat(memberName, \"}\"))) {\n          request.path = request.path.replace(\"{\".concat(memberName, \"}\"), extendedEncodeURIComponent(replacement));\n        }\n        delete input[memberName];\n      } else if (memberTraits.httpHeader) {\n        serializer.write(memberNs, inputMemberValue);\n        headers[memberTraits.httpHeader.toLowerCase()] = String(serializer.flush());\n        delete input[memberName];\n      } else if (typeof memberTraits.httpPrefixHeaders === \"string\") {\n        for (const [key, val] of Object.entries(inputMemberValue)) {\n          const amalgam = memberTraits.httpPrefixHeaders + key;\n          serializer.write([memberNs.getValueSchema(), {\n            httpHeader: amalgam\n          }], val);\n          headers[amalgam.toLowerCase()] = serializer.flush();\n        }\n        delete input[memberName];\n      } else if (memberTraits.httpQuery || memberTraits.httpQueryParams) {\n        this.serializeQuery(memberNs, inputMemberValue, query);\n        delete input[memberName];\n      } else {\n        hasNonHttpBindingMember = true;\n      }\n    }\n    if (hasNonHttpBindingMember && input) {\n      serializer.write(schema, input);\n      payload = serializer.flush();\n    }\n    request.headers = headers;\n    request.query = query;\n    request.body = payload;\n    return request;\n  }\n  serializeQuery(ns, data, query) {\n    const serializer = this.serializer;\n    const traits = ns.getMergedTraits();\n    if (traits.httpQueryParams) {\n      for (const [key, val] of Object.entries(data)) {\n        if (!(key in query)) {\n          const valueSchema = ns.getValueSchema();\n          Object.assign(valueSchema.getMergedTraits(), _objectSpread(_objectSpread({}, traits), {}, {\n            httpQuery: key,\n            httpQueryParams: undefined\n          }));\n          this.serializeQuery(valueSchema, val, query);\n        }\n      }\n      return;\n    }\n    if (ns.isListSchema()) {\n      const sparse = !!ns.getMergedTraits().sparse;\n      const buffer = [];\n      for (const item of data) {\n        serializer.write([ns.getValueSchema(), traits], item);\n        const serializable = serializer.flush();\n        if (sparse || serializable !== undefined) {\n          buffer.push(serializable);\n        }\n      }\n      query[traits.httpQuery] = buffer;\n    } else {\n      serializer.write([ns, traits], data);\n      query[traits.httpQuery] = serializer.flush();\n    }\n  }\n  async deserializeResponse(operationSchema, context, response) {\n    const deserializer = this.deserializer;\n    const ns = NormalizedSchema.of(operationSchema.output);\n    const dataObject = {};\n    if (response.statusCode >= 300) {\n      const bytes = await collectBody(response.body, context);\n      if (bytes.byteLength > 0) {\n        Object.assign(dataObject, await deserializer.read(15, bytes));\n      }\n      await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));\n      throw new Error(\"@smithy/core/protocols - HTTP Protocol error handler failed to throw.\");\n    }\n    for (const header in response.headers) {\n      const value = response.headers[header];\n      delete response.headers[header];\n      response.headers[header.toLowerCase()] = value;\n    }\n    const nonHttpBindingMembers = await this.deserializeHttpMessage(ns, context, response, dataObject);\n    if (nonHttpBindingMembers.length) {\n      const bytes = await collectBody(response.body, context);\n      if (bytes.byteLength > 0) {\n        const dataFromBody = await deserializer.read(ns, bytes);\n        for (const member of nonHttpBindingMembers) {\n          dataObject[member] = dataFromBody[member];\n        }\n      }\n    } else if (nonHttpBindingMembers.discardResponseBody) {\n      await collectBody(response.body, context);\n    }\n    dataObject.$metadata = this.deserializeMetadata(response);\n    return dataObject;\n  }\n  async deserializeHttpMessage(schema, context, response, arg4, arg5) {\n    let dataObject;\n    if (arg4 instanceof Set) {\n      dataObject = arg5;\n    } else {\n      dataObject = arg4;\n    }\n    let discardResponseBody = true;\n    const deserializer = this.deserializer;\n    const ns = NormalizedSchema.of(schema);\n    const nonHttpBindingMembers = [];\n    for (const [memberName, memberSchema] of ns.structIterator()) {\n      const memberTraits = memberSchema.getMemberTraits();\n      if (memberTraits.httpPayload) {\n        discardResponseBody = false;\n        const isStreaming = memberSchema.isStreaming();\n        if (isStreaming) {\n          const isEventStream = memberSchema.isStructSchema();\n          if (isEventStream) {\n            dataObject[memberName] = await this.deserializeEventStream({\n              response,\n              responseSchema: ns\n            });\n          } else {\n            dataObject[memberName] = sdkStreamMixin(response.body);\n          }\n        } else if (response.body) {\n          const bytes = await collectBody(response.body, context);\n          if (bytes.byteLength > 0) {\n            dataObject[memberName] = await deserializer.read(memberSchema, bytes);\n          }\n        }\n      } else if (memberTraits.httpHeader) {\n        const key = String(memberTraits.httpHeader).toLowerCase();\n        const value = response.headers[key];\n        if (null != value) {\n          if (memberSchema.isListSchema()) {\n            const headerListValueSchema = memberSchema.getValueSchema();\n            headerListValueSchema.getMergedTraits().httpHeader = key;\n            let sections;\n            if (headerListValueSchema.isTimestampSchema() && headerListValueSchema.getSchema() === 4) {\n              sections = splitEvery(value, \",\", 2);\n            } else {\n              sections = splitHeader(value);\n            }\n            const list = [];\n            for (const section of sections) {\n              list.push(await deserializer.read(headerListValueSchema, section.trim()));\n            }\n            dataObject[memberName] = list;\n          } else {\n            dataObject[memberName] = await deserializer.read(memberSchema, value);\n          }\n        }\n      } else if (memberTraits.httpPrefixHeaders !== undefined) {\n        dataObject[memberName] = {};\n        for (const [header, value] of Object.entries(response.headers)) {\n          if (header.startsWith(memberTraits.httpPrefixHeaders)) {\n            const valueSchema = memberSchema.getValueSchema();\n            valueSchema.getMergedTraits().httpHeader = header;\n            dataObject[memberName][header.slice(memberTraits.httpPrefixHeaders.length)] = await deserializer.read(valueSchema, value);\n          }\n        }\n      } else if (memberTraits.httpResponseCode) {\n        dataObject[memberName] = response.statusCode;\n      } else {\n        nonHttpBindingMembers.push(memberName);\n      }\n    }\n    nonHttpBindingMembers.discardResponseBody = discardResponseBody;\n    return nonHttpBindingMembers;\n  }\n}","map":{"version":3,"names":["NormalizedSchema","translateTraits","splitEvery","splitHeader","HttpRequest","sdkStreamMixin","collectBody","extendedEncodeURIComponent","HttpProtocol","HttpBindingProtocol","serializeRequest","operationSchema","_input","context","input","_objectSpread","serializer","query","headers","endpoint","ns","of","schema","getSchema","hasNonHttpBindingMember","payload","request","protocol","hostname","port","undefined","path","fragment","body","updateServiceEndpoint","setHostPrefix","opTraits","traits","http","method","search","split","traitSearchParams","URLSearchParams","Object","assign","fromEntries","memberName","memberNs","structIterator","_memberNs$getMergedTr","memberTraits","getMergedTraits","inputMemberValue","isIdempotencyToken","httpPayload","isStreaming","isEventStream","isStructSchema","serializeEventStream","eventStream","requestSchema","write","flush","httpLabel","replacement","includes","concat","replace","map","join","httpHeader","toLowerCase","String","httpPrefixHeaders","key","val","entries","amalgam","getValueSchema","httpQuery","httpQueryParams","serializeQuery","data","valueSchema","isListSchema","sparse","buffer","item","serializable","push","deserializeResponse","response","deserializer","output","dataObject","statusCode","bytes","byteLength","read","handleError","deserializeMetadata","Error","header","value","nonHttpBindingMembers","deserializeHttpMessage","length","dataFromBody","member","discardResponseBody","$metadata","arg4","arg5","Set","memberSchema","getMemberTraits","deserializeEventStream","responseSchema","headerListValueSchema","sections","isTimestampSchema","list","section","trim","startsWith","slice","httpResponseCode"],"sources":["/home/rcts/Email-differ/Frontend/node_modules/@smithy/core/dist-es/submodules/protocols/HttpBindingProtocol.js"],"sourcesContent":["import { NormalizedSchema, translateTraits } from \"@smithy/core/schema\";\nimport { splitEvery, splitHeader } from \"@smithy/core/serde\";\nimport { HttpRequest } from \"@smithy/protocol-http\";\nimport { sdkStreamMixin } from \"@smithy/util-stream\";\nimport { collectBody } from \"./collect-stream-body\";\nimport { extendedEncodeURIComponent } from \"./extended-encode-uri-component\";\nimport { HttpProtocol } from \"./HttpProtocol\";\nexport class HttpBindingProtocol extends HttpProtocol {\n    async serializeRequest(operationSchema, _input, context) {\n        const input = {\n            ...(_input ?? {}),\n        };\n        const serializer = this.serializer;\n        const query = {};\n        const headers = {};\n        const endpoint = await context.endpoint();\n        const ns = NormalizedSchema.of(operationSchema?.input);\n        const schema = ns.getSchema();\n        let hasNonHttpBindingMember = false;\n        let payload;\n        const request = new HttpRequest({\n            protocol: \"\",\n            hostname: \"\",\n            port: undefined,\n            path: \"\",\n            fragment: undefined,\n            query: query,\n            headers: headers,\n            body: undefined,\n        });\n        if (endpoint) {\n            this.updateServiceEndpoint(request, endpoint);\n            this.setHostPrefix(request, operationSchema, input);\n            const opTraits = translateTraits(operationSchema.traits);\n            if (opTraits.http) {\n                request.method = opTraits.http[0];\n                const [path, search] = opTraits.http[1].split(\"?\");\n                if (request.path == \"/\") {\n                    request.path = path;\n                }\n                else {\n                    request.path += path;\n                }\n                const traitSearchParams = new URLSearchParams(search ?? \"\");\n                Object.assign(query, Object.fromEntries(traitSearchParams));\n            }\n        }\n        for (const [memberName, memberNs] of ns.structIterator()) {\n            const memberTraits = memberNs.getMergedTraits() ?? {};\n            const inputMemberValue = input[memberName];\n            if (inputMemberValue == null && !memberNs.isIdempotencyToken()) {\n                continue;\n            }\n            if (memberTraits.httpPayload) {\n                const isStreaming = memberNs.isStreaming();\n                if (isStreaming) {\n                    const isEventStream = memberNs.isStructSchema();\n                    if (isEventStream) {\n                        if (input[memberName]) {\n                            payload = await this.serializeEventStream({\n                                eventStream: input[memberName],\n                                requestSchema: ns,\n                            });\n                        }\n                    }\n                    else {\n                        payload = inputMemberValue;\n                    }\n                }\n                else {\n                    serializer.write(memberNs, inputMemberValue);\n                    payload = serializer.flush();\n                }\n                delete input[memberName];\n            }\n            else if (memberTraits.httpLabel) {\n                serializer.write(memberNs, inputMemberValue);\n                const replacement = serializer.flush();\n                if (request.path.includes(`{${memberName}+}`)) {\n                    request.path = request.path.replace(`{${memberName}+}`, replacement.split(\"/\").map(extendedEncodeURIComponent).join(\"/\"));\n                }\n                else if (request.path.includes(`{${memberName}}`)) {\n                    request.path = request.path.replace(`{${memberName}}`, extendedEncodeURIComponent(replacement));\n                }\n                delete input[memberName];\n            }\n            else if (memberTraits.httpHeader) {\n                serializer.write(memberNs, inputMemberValue);\n                headers[memberTraits.httpHeader.toLowerCase()] = String(serializer.flush());\n                delete input[memberName];\n            }\n            else if (typeof memberTraits.httpPrefixHeaders === \"string\") {\n                for (const [key, val] of Object.entries(inputMemberValue)) {\n                    const amalgam = memberTraits.httpPrefixHeaders + key;\n                    serializer.write([memberNs.getValueSchema(), { httpHeader: amalgam }], val);\n                    headers[amalgam.toLowerCase()] = serializer.flush();\n                }\n                delete input[memberName];\n            }\n            else if (memberTraits.httpQuery || memberTraits.httpQueryParams) {\n                this.serializeQuery(memberNs, inputMemberValue, query);\n                delete input[memberName];\n            }\n            else {\n                hasNonHttpBindingMember = true;\n            }\n        }\n        if (hasNonHttpBindingMember && input) {\n            serializer.write(schema, input);\n            payload = serializer.flush();\n        }\n        request.headers = headers;\n        request.query = query;\n        request.body = payload;\n        return request;\n    }\n    serializeQuery(ns, data, query) {\n        const serializer = this.serializer;\n        const traits = ns.getMergedTraits();\n        if (traits.httpQueryParams) {\n            for (const [key, val] of Object.entries(data)) {\n                if (!(key in query)) {\n                    const valueSchema = ns.getValueSchema();\n                    Object.assign(valueSchema.getMergedTraits(), {\n                        ...traits,\n                        httpQuery: key,\n                        httpQueryParams: undefined,\n                    });\n                    this.serializeQuery(valueSchema, val, query);\n                }\n            }\n            return;\n        }\n        if (ns.isListSchema()) {\n            const sparse = !!ns.getMergedTraits().sparse;\n            const buffer = [];\n            for (const item of data) {\n                serializer.write([ns.getValueSchema(), traits], item);\n                const serializable = serializer.flush();\n                if (sparse || serializable !== undefined) {\n                    buffer.push(serializable);\n                }\n            }\n            query[traits.httpQuery] = buffer;\n        }\n        else {\n            serializer.write([ns, traits], data);\n            query[traits.httpQuery] = serializer.flush();\n        }\n    }\n    async deserializeResponse(operationSchema, context, response) {\n        const deserializer = this.deserializer;\n        const ns = NormalizedSchema.of(operationSchema.output);\n        const dataObject = {};\n        if (response.statusCode >= 300) {\n            const bytes = await collectBody(response.body, context);\n            if (bytes.byteLength > 0) {\n                Object.assign(dataObject, await deserializer.read(15, bytes));\n            }\n            await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));\n            throw new Error(\"@smithy/core/protocols - HTTP Protocol error handler failed to throw.\");\n        }\n        for (const header in response.headers) {\n            const value = response.headers[header];\n            delete response.headers[header];\n            response.headers[header.toLowerCase()] = value;\n        }\n        const nonHttpBindingMembers = await this.deserializeHttpMessage(ns, context, response, dataObject);\n        if (nonHttpBindingMembers.length) {\n            const bytes = await collectBody(response.body, context);\n            if (bytes.byteLength > 0) {\n                const dataFromBody = await deserializer.read(ns, bytes);\n                for (const member of nonHttpBindingMembers) {\n                    dataObject[member] = dataFromBody[member];\n                }\n            }\n        }\n        else if (nonHttpBindingMembers.discardResponseBody) {\n            await collectBody(response.body, context);\n        }\n        dataObject.$metadata = this.deserializeMetadata(response);\n        return dataObject;\n    }\n    async deserializeHttpMessage(schema, context, response, arg4, arg5) {\n        let dataObject;\n        if (arg4 instanceof Set) {\n            dataObject = arg5;\n        }\n        else {\n            dataObject = arg4;\n        }\n        let discardResponseBody = true;\n        const deserializer = this.deserializer;\n        const ns = NormalizedSchema.of(schema);\n        const nonHttpBindingMembers = [];\n        for (const [memberName, memberSchema] of ns.structIterator()) {\n            const memberTraits = memberSchema.getMemberTraits();\n            if (memberTraits.httpPayload) {\n                discardResponseBody = false;\n                const isStreaming = memberSchema.isStreaming();\n                if (isStreaming) {\n                    const isEventStream = memberSchema.isStructSchema();\n                    if (isEventStream) {\n                        dataObject[memberName] = await this.deserializeEventStream({\n                            response,\n                            responseSchema: ns,\n                        });\n                    }\n                    else {\n                        dataObject[memberName] = sdkStreamMixin(response.body);\n                    }\n                }\n                else if (response.body) {\n                    const bytes = await collectBody(response.body, context);\n                    if (bytes.byteLength > 0) {\n                        dataObject[memberName] = await deserializer.read(memberSchema, bytes);\n                    }\n                }\n            }\n            else if (memberTraits.httpHeader) {\n                const key = String(memberTraits.httpHeader).toLowerCase();\n                const value = response.headers[key];\n                if (null != value) {\n                    if (memberSchema.isListSchema()) {\n                        const headerListValueSchema = memberSchema.getValueSchema();\n                        headerListValueSchema.getMergedTraits().httpHeader = key;\n                        let sections;\n                        if (headerListValueSchema.isTimestampSchema() &&\n                            headerListValueSchema.getSchema() === 4) {\n                            sections = splitEvery(value, \",\", 2);\n                        }\n                        else {\n                            sections = splitHeader(value);\n                        }\n                        const list = [];\n                        for (const section of sections) {\n                            list.push(await deserializer.read(headerListValueSchema, section.trim()));\n                        }\n                        dataObject[memberName] = list;\n                    }\n                    else {\n                        dataObject[memberName] = await deserializer.read(memberSchema, value);\n                    }\n                }\n            }\n            else if (memberTraits.httpPrefixHeaders !== undefined) {\n                dataObject[memberName] = {};\n                for (const [header, value] of Object.entries(response.headers)) {\n                    if (header.startsWith(memberTraits.httpPrefixHeaders)) {\n                        const valueSchema = memberSchema.getValueSchema();\n                        valueSchema.getMergedTraits().httpHeader = header;\n                        dataObject[memberName][header.slice(memberTraits.httpPrefixHeaders.length)] = await deserializer.read(valueSchema, value);\n                    }\n                }\n            }\n            else if (memberTraits.httpResponseCode) {\n                dataObject[memberName] = response.statusCode;\n            }\n            else {\n                nonHttpBindingMembers.push(memberName);\n            }\n        }\n        nonHttpBindingMembers.discardResponseBody = discardResponseBody;\n        return nonHttpBindingMembers;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}