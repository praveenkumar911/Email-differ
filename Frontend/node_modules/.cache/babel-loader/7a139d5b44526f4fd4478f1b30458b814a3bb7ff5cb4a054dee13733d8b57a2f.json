{"ast":null,"code":"import _defineProperty from \"/home/rcts/Email-differ/Frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { XmlNode, XmlText } from \"@aws-sdk/xml-builder\";\nimport { determineTimestampFormat } from \"@smithy/core/protocols\";\nimport { NormalizedSchema } from \"@smithy/core/schema\";\nimport { generateIdempotencyToken, NumericValue } from \"@smithy/core/serde\";\nimport { dateToUtcString } from \"@smithy/smithy-client\";\nimport { fromBase64, toBase64 } from \"@smithy/util-base64\";\nimport { SerdeContextConfig } from \"../ConfigurableSerdeContext\";\nimport { serializingStructIterator } from \"../structIterator\";\nexport class XmlShapeSerializer extends SerdeContextConfig {\n  constructor(settings) {\n    super();\n    _defineProperty(this, \"settings\", void 0);\n    _defineProperty(this, \"stringBuffer\", void 0);\n    _defineProperty(this, \"byteBuffer\", void 0);\n    _defineProperty(this, \"buffer\", void 0);\n    this.settings = settings;\n  }\n  write(schema, value) {\n    const ns = NormalizedSchema.of(schema);\n    if (ns.isStringSchema() && typeof value === \"string\") {\n      this.stringBuffer = value;\n    } else if (ns.isBlobSchema()) {\n      var _this$serdeContext$ba, _this$serdeContext;\n      this.byteBuffer = \"byteLength\" in value ? value : ((_this$serdeContext$ba = (_this$serdeContext = this.serdeContext) === null || _this$serdeContext === void 0 ? void 0 : _this$serdeContext.base64Decoder) !== null && _this$serdeContext$ba !== void 0 ? _this$serdeContext$ba : fromBase64)(value);\n    } else {\n      this.buffer = this.writeStruct(ns, value, undefined);\n      const traits = ns.getMergedTraits();\n      if (traits.httpPayload && !traits.xmlName) {\n        this.buffer.withName(ns.getName());\n      }\n    }\n  }\n  flush() {\n    if (this.byteBuffer !== undefined) {\n      const bytes = this.byteBuffer;\n      delete this.byteBuffer;\n      return bytes;\n    }\n    if (this.stringBuffer !== undefined) {\n      const str = this.stringBuffer;\n      delete this.stringBuffer;\n      return str;\n    }\n    const buffer = this.buffer;\n    if (this.settings.xmlNamespace) {\n      var _buffer$attributes;\n      if (!(buffer !== null && buffer !== void 0 && (_buffer$attributes = buffer.attributes) !== null && _buffer$attributes !== void 0 && _buffer$attributes[\"xmlns\"])) {\n        buffer.addAttribute(\"xmlns\", this.settings.xmlNamespace);\n      }\n    }\n    delete this.buffer;\n    return buffer.toString();\n  }\n  writeStruct(ns, value, parentXmlns) {\n    var _ns$getMemberTraits$x, _traits$xmlName;\n    const traits = ns.getMergedTraits();\n    const name = ns.isMemberSchema() && !traits.httpPayload ? (_ns$getMemberTraits$x = ns.getMemberTraits().xmlName) !== null && _ns$getMemberTraits$x !== void 0 ? _ns$getMemberTraits$x : ns.getMemberName() : (_traits$xmlName = traits.xmlName) !== null && _traits$xmlName !== void 0 ? _traits$xmlName : ns.getName();\n    if (!name || !ns.isStructSchema()) {\n      throw new Error(\"@aws-sdk/core/protocols - xml serializer, cannot write struct with empty name or non-struct, schema=\".concat(ns.getName(true), \".\"));\n    }\n    const structXmlNode = XmlNode.of(name);\n    const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);\n    for (const [memberName, memberSchema] of serializingStructIterator(ns, value)) {\n      const val = value[memberName];\n      if (val != null || memberSchema.isIdempotencyToken()) {\n        if (memberSchema.getMergedTraits().xmlAttribute) {\n          var _memberSchema$getMerg;\n          structXmlNode.addAttribute((_memberSchema$getMerg = memberSchema.getMergedTraits().xmlName) !== null && _memberSchema$getMerg !== void 0 ? _memberSchema$getMerg : memberName, this.writeSimple(memberSchema, val));\n          continue;\n        }\n        if (memberSchema.isListSchema()) {\n          this.writeList(memberSchema, val, structXmlNode, xmlns);\n        } else if (memberSchema.isMapSchema()) {\n          this.writeMap(memberSchema, val, structXmlNode, xmlns);\n        } else if (memberSchema.isStructSchema()) {\n          structXmlNode.addChildNode(this.writeStruct(memberSchema, val, xmlns));\n        } else {\n          var _memberSchema$getMerg2;\n          const memberNode = XmlNode.of((_memberSchema$getMerg2 = memberSchema.getMergedTraits().xmlName) !== null && _memberSchema$getMerg2 !== void 0 ? _memberSchema$getMerg2 : memberSchema.getMemberName());\n          this.writeSimpleInto(memberSchema, val, memberNode, xmlns);\n          structXmlNode.addChildNode(memberNode);\n        }\n      }\n    }\n    const {\n      $unknown\n    } = value;\n    if ($unknown && ns.isUnionSchema() && Array.isArray($unknown) && Object.keys(value).length === 1) {\n      const [k, v] = $unknown;\n      const node = XmlNode.of(k);\n      if (typeof v !== \"string\") {\n        if (value instanceof XmlNode || value instanceof XmlText) {\n          structXmlNode.addChildNode(value);\n        } else {\n          throw new Error(\"@aws-sdk - $unknown union member in XML requires \" + \"value of type string, @aws-sdk/xml-builder::XmlNode or XmlText.\");\n        }\n      }\n      this.writeSimpleInto(0, v, node, xmlns);\n      structXmlNode.addChildNode(node);\n    }\n    if (xmlns) {\n      structXmlNode.addAttribute(xmlnsAttr, xmlns);\n    }\n    return structXmlNode;\n  }\n  writeList(listMember, array, container, parentXmlns) {\n    if (!listMember.isMemberSchema()) {\n      throw new Error(\"@aws-sdk/core/protocols - xml serializer, cannot write non-member list: \".concat(listMember.getName(true)));\n    }\n    const listTraits = listMember.getMergedTraits();\n    const listValueSchema = listMember.getValueSchema();\n    const listValueTraits = listValueSchema.getMergedTraits();\n    const sparse = !!listValueTraits.sparse;\n    const flat = !!listTraits.xmlFlattened;\n    const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(listMember, parentXmlns);\n    const writeItem = (container, value) => {\n      if (listValueSchema.isListSchema()) {\n        this.writeList(listValueSchema, Array.isArray(value) ? value : [value], container, xmlns);\n      } else if (listValueSchema.isMapSchema()) {\n        this.writeMap(listValueSchema, value, container, xmlns);\n      } else if (listValueSchema.isStructSchema()) {\n        var _listTraits$xmlName, _listValueTraits$xmlN;\n        const struct = this.writeStruct(listValueSchema, value, xmlns);\n        container.addChildNode(struct.withName(flat ? (_listTraits$xmlName = listTraits.xmlName) !== null && _listTraits$xmlName !== void 0 ? _listTraits$xmlName : listMember.getMemberName() : (_listValueTraits$xmlN = listValueTraits.xmlName) !== null && _listValueTraits$xmlN !== void 0 ? _listValueTraits$xmlN : \"member\"));\n      } else {\n        var _listTraits$xmlName2, _listValueTraits$xmlN2;\n        const listItemNode = XmlNode.of(flat ? (_listTraits$xmlName2 = listTraits.xmlName) !== null && _listTraits$xmlName2 !== void 0 ? _listTraits$xmlName2 : listMember.getMemberName() : (_listValueTraits$xmlN2 = listValueTraits.xmlName) !== null && _listValueTraits$xmlN2 !== void 0 ? _listValueTraits$xmlN2 : \"member\");\n        this.writeSimpleInto(listValueSchema, value, listItemNode, xmlns);\n        container.addChildNode(listItemNode);\n      }\n    };\n    if (flat) {\n      for (const value of array) {\n        if (sparse || value != null) {\n          writeItem(container, value);\n        }\n      }\n    } else {\n      var _listTraits$xmlName3;\n      const listNode = XmlNode.of((_listTraits$xmlName3 = listTraits.xmlName) !== null && _listTraits$xmlName3 !== void 0 ? _listTraits$xmlName3 : listMember.getMemberName());\n      if (xmlns) {\n        listNode.addAttribute(xmlnsAttr, xmlns);\n      }\n      for (const value of array) {\n        if (sparse || value != null) {\n          writeItem(listNode, value);\n        }\n      }\n      container.addChildNode(listNode);\n    }\n  }\n  writeMap(mapMember, map, container, parentXmlns) {\n    var _mapKeyTraits$xmlName, _mapValueTraits$xmlNa;\n    let containerIsMap = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    if (!mapMember.isMemberSchema()) {\n      throw new Error(\"@aws-sdk/core/protocols - xml serializer, cannot write non-member map: \".concat(mapMember.getName(true)));\n    }\n    const mapTraits = mapMember.getMergedTraits();\n    const mapKeySchema = mapMember.getKeySchema();\n    const mapKeyTraits = mapKeySchema.getMergedTraits();\n    const keyTag = (_mapKeyTraits$xmlName = mapKeyTraits.xmlName) !== null && _mapKeyTraits$xmlName !== void 0 ? _mapKeyTraits$xmlName : \"key\";\n    const mapValueSchema = mapMember.getValueSchema();\n    const mapValueTraits = mapValueSchema.getMergedTraits();\n    const valueTag = (_mapValueTraits$xmlNa = mapValueTraits.xmlName) !== null && _mapValueTraits$xmlNa !== void 0 ? _mapValueTraits$xmlNa : \"value\";\n    const sparse = !!mapValueTraits.sparse;\n    const flat = !!mapTraits.xmlFlattened;\n    const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(mapMember, parentXmlns);\n    const addKeyValue = (entry, key, val) => {\n      const keyNode = XmlNode.of(keyTag, key);\n      const [keyXmlnsAttr, keyXmlns] = this.getXmlnsAttribute(mapKeySchema, xmlns);\n      if (keyXmlns) {\n        keyNode.addAttribute(keyXmlnsAttr, keyXmlns);\n      }\n      entry.addChildNode(keyNode);\n      let valueNode = XmlNode.of(valueTag);\n      if (mapValueSchema.isListSchema()) {\n        this.writeList(mapValueSchema, val, valueNode, xmlns);\n      } else if (mapValueSchema.isMapSchema()) {\n        this.writeMap(mapValueSchema, val, valueNode, xmlns, true);\n      } else if (mapValueSchema.isStructSchema()) {\n        valueNode = this.writeStruct(mapValueSchema, val, xmlns);\n      } else {\n        this.writeSimpleInto(mapValueSchema, val, valueNode, xmlns);\n      }\n      entry.addChildNode(valueNode);\n    };\n    if (flat) {\n      for (const [key, val] of Object.entries(map)) {\n        if (sparse || val != null) {\n          var _mapTraits$xmlName;\n          const entry = XmlNode.of((_mapTraits$xmlName = mapTraits.xmlName) !== null && _mapTraits$xmlName !== void 0 ? _mapTraits$xmlName : mapMember.getMemberName());\n          addKeyValue(entry, key, val);\n          container.addChildNode(entry);\n        }\n      }\n    } else {\n      let mapNode;\n      if (!containerIsMap) {\n        var _mapTraits$xmlName2;\n        mapNode = XmlNode.of((_mapTraits$xmlName2 = mapTraits.xmlName) !== null && _mapTraits$xmlName2 !== void 0 ? _mapTraits$xmlName2 : mapMember.getMemberName());\n        if (xmlns) {\n          mapNode.addAttribute(xmlnsAttr, xmlns);\n        }\n        container.addChildNode(mapNode);\n      }\n      for (const [key, val] of Object.entries(map)) {\n        if (sparse || val != null) {\n          const entry = XmlNode.of(\"entry\");\n          addKeyValue(entry, key, val);\n          (containerIsMap ? container : mapNode).addChildNode(entry);\n        }\n      }\n    }\n  }\n  writeSimple(_schema, value) {\n    if (null === value) {\n      throw new Error(\"@aws-sdk/core/protocols - (XML serializer) cannot write null value.\");\n    }\n    const ns = NormalizedSchema.of(_schema);\n    let nodeContents = null;\n    if (value && typeof value === \"object\") {\n      if (ns.isBlobSchema()) {\n        var _this$serdeContext$ba2, _this$serdeContext2;\n        nodeContents = ((_this$serdeContext$ba2 = (_this$serdeContext2 = this.serdeContext) === null || _this$serdeContext2 === void 0 ? void 0 : _this$serdeContext2.base64Encoder) !== null && _this$serdeContext$ba2 !== void 0 ? _this$serdeContext$ba2 : toBase64)(value);\n      } else if (ns.isTimestampSchema() && value instanceof Date) {\n        const format = determineTimestampFormat(ns, this.settings);\n        switch (format) {\n          case 5:\n            nodeContents = value.toISOString().replace(\".000Z\", \"Z\");\n            break;\n          case 6:\n            nodeContents = dateToUtcString(value);\n            break;\n          case 7:\n            nodeContents = String(value.getTime() / 1000);\n            break;\n          default:\n            console.warn(\"Missing timestamp format, using http date\", value);\n            nodeContents = dateToUtcString(value);\n            break;\n        }\n      } else if (ns.isBigDecimalSchema() && value) {\n        if (value instanceof NumericValue) {\n          return value.string;\n        }\n        return String(value);\n      } else if (ns.isMapSchema() || ns.isListSchema()) {\n        throw new Error(\"@aws-sdk/core/protocols - xml serializer, cannot call _write() on List/Map schema, call writeList or writeMap() instead.\");\n      } else {\n        throw new Error(\"@aws-sdk/core/protocols - xml serializer, unhandled schema type for object value and schema: \".concat(ns.getName(true)));\n      }\n    }\n    if (ns.isBooleanSchema() || ns.isNumericSchema() || ns.isBigIntegerSchema() || ns.isBigDecimalSchema()) {\n      nodeContents = String(value);\n    }\n    if (ns.isStringSchema()) {\n      if (value === undefined && ns.isIdempotencyToken()) {\n        nodeContents = generateIdempotencyToken();\n      } else {\n        nodeContents = String(value);\n      }\n    }\n    if (nodeContents === null) {\n      throw new Error(\"Unhandled schema-value pair \".concat(ns.getName(true), \"=\").concat(value));\n    }\n    return nodeContents;\n  }\n  writeSimpleInto(_schema, value, into, parentXmlns) {\n    const nodeContents = this.writeSimple(_schema, value);\n    const ns = NormalizedSchema.of(_schema);\n    const content = new XmlText(nodeContents);\n    const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);\n    if (xmlns) {\n      into.addAttribute(xmlnsAttr, xmlns);\n    }\n    into.addChildNode(content);\n  }\n  getXmlnsAttribute(ns, parentXmlns) {\n    var _traits$xmlNamespace;\n    const traits = ns.getMergedTraits();\n    const [prefix, xmlns] = (_traits$xmlNamespace = traits.xmlNamespace) !== null && _traits$xmlNamespace !== void 0 ? _traits$xmlNamespace : [];\n    if (xmlns && xmlns !== parentXmlns) {\n      return [prefix ? \"xmlns:\".concat(prefix) : \"xmlns\", xmlns];\n    }\n    return [void 0, void 0];\n  }\n}","map":{"version":3,"names":["XmlNode","XmlText","determineTimestampFormat","NormalizedSchema","generateIdempotencyToken","NumericValue","dateToUtcString","fromBase64","toBase64","SerdeContextConfig","serializingStructIterator","XmlShapeSerializer","constructor","settings","_defineProperty","write","schema","value","ns","of","isStringSchema","stringBuffer","isBlobSchema","_this$serdeContext$ba","_this$serdeContext","byteBuffer","serdeContext","base64Decoder","buffer","writeStruct","undefined","traits","getMergedTraits","httpPayload","xmlName","withName","getName","flush","bytes","str","xmlNamespace","_buffer$attributes","attributes","addAttribute","toString","parentXmlns","_ns$getMemberTraits$x","_traits$xmlName","name","isMemberSchema","getMemberTraits","getMemberName","isStructSchema","Error","concat","structXmlNode","xmlnsAttr","xmlns","getXmlnsAttribute","memberName","memberSchema","val","isIdempotencyToken","xmlAttribute","_memberSchema$getMerg","writeSimple","isListSchema","writeList","isMapSchema","writeMap","addChildNode","_memberSchema$getMerg2","memberNode","writeSimpleInto","$unknown","isUnionSchema","Array","isArray","Object","keys","length","k","v","node","listMember","array","container","listTraits","listValueSchema","getValueSchema","listValueTraits","sparse","flat","xmlFlattened","writeItem","_listTraits$xmlName","_listValueTraits$xmlN","struct","_listTraits$xmlName2","_listValueTraits$xmlN2","listItemNode","_listTraits$xmlName3","listNode","mapMember","map","_mapKeyTraits$xmlName","_mapValueTraits$xmlNa","containerIsMap","arguments","mapTraits","mapKeySchema","getKeySchema","mapKeyTraits","keyTag","mapValueSchema","mapValueTraits","valueTag","addKeyValue","entry","key","keyNode","keyXmlnsAttr","keyXmlns","valueNode","entries","_mapTraits$xmlName","mapNode","_mapTraits$xmlName2","_schema","nodeContents","_this$serdeContext$ba2","_this$serdeContext2","base64Encoder","isTimestampSchema","Date","format","toISOString","replace","String","getTime","console","warn","isBigDecimalSchema","string","isBooleanSchema","isNumericSchema","isBigIntegerSchema","into","content","_traits$xmlNamespace","prefix"],"sources":["/home/rcts/Email-differ/Frontend/node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlShapeSerializer.js"],"sourcesContent":["import { XmlNode, XmlText } from \"@aws-sdk/xml-builder\";\nimport { determineTimestampFormat } from \"@smithy/core/protocols\";\nimport { NormalizedSchema } from \"@smithy/core/schema\";\nimport { generateIdempotencyToken, NumericValue } from \"@smithy/core/serde\";\nimport { dateToUtcString } from \"@smithy/smithy-client\";\nimport { fromBase64, toBase64 } from \"@smithy/util-base64\";\nimport { SerdeContextConfig } from \"../ConfigurableSerdeContext\";\nimport { serializingStructIterator } from \"../structIterator\";\nexport class XmlShapeSerializer extends SerdeContextConfig {\n    settings;\n    stringBuffer;\n    byteBuffer;\n    buffer;\n    constructor(settings) {\n        super();\n        this.settings = settings;\n    }\n    write(schema, value) {\n        const ns = NormalizedSchema.of(schema);\n        if (ns.isStringSchema() && typeof value === \"string\") {\n            this.stringBuffer = value;\n        }\n        else if (ns.isBlobSchema()) {\n            this.byteBuffer =\n                \"byteLength\" in value\n                    ? value\n                    : (this.serdeContext?.base64Decoder ?? fromBase64)(value);\n        }\n        else {\n            this.buffer = this.writeStruct(ns, value, undefined);\n            const traits = ns.getMergedTraits();\n            if (traits.httpPayload && !traits.xmlName) {\n                this.buffer.withName(ns.getName());\n            }\n        }\n    }\n    flush() {\n        if (this.byteBuffer !== undefined) {\n            const bytes = this.byteBuffer;\n            delete this.byteBuffer;\n            return bytes;\n        }\n        if (this.stringBuffer !== undefined) {\n            const str = this.stringBuffer;\n            delete this.stringBuffer;\n            return str;\n        }\n        const buffer = this.buffer;\n        if (this.settings.xmlNamespace) {\n            if (!buffer?.attributes?.[\"xmlns\"]) {\n                buffer.addAttribute(\"xmlns\", this.settings.xmlNamespace);\n            }\n        }\n        delete this.buffer;\n        return buffer.toString();\n    }\n    writeStruct(ns, value, parentXmlns) {\n        const traits = ns.getMergedTraits();\n        const name = ns.isMemberSchema() && !traits.httpPayload\n            ? ns.getMemberTraits().xmlName ?? ns.getMemberName()\n            : traits.xmlName ?? ns.getName();\n        if (!name || !ns.isStructSchema()) {\n            throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write struct with empty name or non-struct, schema=${ns.getName(true)}.`);\n        }\n        const structXmlNode = XmlNode.of(name);\n        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);\n        for (const [memberName, memberSchema] of serializingStructIterator(ns, value)) {\n            const val = value[memberName];\n            if (val != null || memberSchema.isIdempotencyToken()) {\n                if (memberSchema.getMergedTraits().xmlAttribute) {\n                    structXmlNode.addAttribute(memberSchema.getMergedTraits().xmlName ?? memberName, this.writeSimple(memberSchema, val));\n                    continue;\n                }\n                if (memberSchema.isListSchema()) {\n                    this.writeList(memberSchema, val, structXmlNode, xmlns);\n                }\n                else if (memberSchema.isMapSchema()) {\n                    this.writeMap(memberSchema, val, structXmlNode, xmlns);\n                }\n                else if (memberSchema.isStructSchema()) {\n                    structXmlNode.addChildNode(this.writeStruct(memberSchema, val, xmlns));\n                }\n                else {\n                    const memberNode = XmlNode.of(memberSchema.getMergedTraits().xmlName ?? memberSchema.getMemberName());\n                    this.writeSimpleInto(memberSchema, val, memberNode, xmlns);\n                    structXmlNode.addChildNode(memberNode);\n                }\n            }\n        }\n        const { $unknown } = value;\n        if ($unknown && ns.isUnionSchema() && Array.isArray($unknown) && Object.keys(value).length === 1) {\n            const [k, v] = $unknown;\n            const node = XmlNode.of(k);\n            if (typeof v !== \"string\") {\n                if (value instanceof XmlNode || value instanceof XmlText) {\n                    structXmlNode.addChildNode(value);\n                }\n                else {\n                    throw new Error(`@aws-sdk - $unknown union member in XML requires ` +\n                        `value of type string, @aws-sdk/xml-builder::XmlNode or XmlText.`);\n                }\n            }\n            this.writeSimpleInto(0, v, node, xmlns);\n            structXmlNode.addChildNode(node);\n        }\n        if (xmlns) {\n            structXmlNode.addAttribute(xmlnsAttr, xmlns);\n        }\n        return structXmlNode;\n    }\n    writeList(listMember, array, container, parentXmlns) {\n        if (!listMember.isMemberSchema()) {\n            throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member list: ${listMember.getName(true)}`);\n        }\n        const listTraits = listMember.getMergedTraits();\n        const listValueSchema = listMember.getValueSchema();\n        const listValueTraits = listValueSchema.getMergedTraits();\n        const sparse = !!listValueTraits.sparse;\n        const flat = !!listTraits.xmlFlattened;\n        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(listMember, parentXmlns);\n        const writeItem = (container, value) => {\n            if (listValueSchema.isListSchema()) {\n                this.writeList(listValueSchema, Array.isArray(value) ? value : [value], container, xmlns);\n            }\n            else if (listValueSchema.isMapSchema()) {\n                this.writeMap(listValueSchema, value, container, xmlns);\n            }\n            else if (listValueSchema.isStructSchema()) {\n                const struct = this.writeStruct(listValueSchema, value, xmlns);\n                container.addChildNode(struct.withName(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? \"member\"));\n            }\n            else {\n                const listItemNode = XmlNode.of(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? \"member\");\n                this.writeSimpleInto(listValueSchema, value, listItemNode, xmlns);\n                container.addChildNode(listItemNode);\n            }\n        };\n        if (flat) {\n            for (const value of array) {\n                if (sparse || value != null) {\n                    writeItem(container, value);\n                }\n            }\n        }\n        else {\n            const listNode = XmlNode.of(listTraits.xmlName ?? listMember.getMemberName());\n            if (xmlns) {\n                listNode.addAttribute(xmlnsAttr, xmlns);\n            }\n            for (const value of array) {\n                if (sparse || value != null) {\n                    writeItem(listNode, value);\n                }\n            }\n            container.addChildNode(listNode);\n        }\n    }\n    writeMap(mapMember, map, container, parentXmlns, containerIsMap = false) {\n        if (!mapMember.isMemberSchema()) {\n            throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member map: ${mapMember.getName(true)}`);\n        }\n        const mapTraits = mapMember.getMergedTraits();\n        const mapKeySchema = mapMember.getKeySchema();\n        const mapKeyTraits = mapKeySchema.getMergedTraits();\n        const keyTag = mapKeyTraits.xmlName ?? \"key\";\n        const mapValueSchema = mapMember.getValueSchema();\n        const mapValueTraits = mapValueSchema.getMergedTraits();\n        const valueTag = mapValueTraits.xmlName ?? \"value\";\n        const sparse = !!mapValueTraits.sparse;\n        const flat = !!mapTraits.xmlFlattened;\n        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(mapMember, parentXmlns);\n        const addKeyValue = (entry, key, val) => {\n            const keyNode = XmlNode.of(keyTag, key);\n            const [keyXmlnsAttr, keyXmlns] = this.getXmlnsAttribute(mapKeySchema, xmlns);\n            if (keyXmlns) {\n                keyNode.addAttribute(keyXmlnsAttr, keyXmlns);\n            }\n            entry.addChildNode(keyNode);\n            let valueNode = XmlNode.of(valueTag);\n            if (mapValueSchema.isListSchema()) {\n                this.writeList(mapValueSchema, val, valueNode, xmlns);\n            }\n            else if (mapValueSchema.isMapSchema()) {\n                this.writeMap(mapValueSchema, val, valueNode, xmlns, true);\n            }\n            else if (mapValueSchema.isStructSchema()) {\n                valueNode = this.writeStruct(mapValueSchema, val, xmlns);\n            }\n            else {\n                this.writeSimpleInto(mapValueSchema, val, valueNode, xmlns);\n            }\n            entry.addChildNode(valueNode);\n        };\n        if (flat) {\n            for (const [key, val] of Object.entries(map)) {\n                if (sparse || val != null) {\n                    const entry = XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());\n                    addKeyValue(entry, key, val);\n                    container.addChildNode(entry);\n                }\n            }\n        }\n        else {\n            let mapNode;\n            if (!containerIsMap) {\n                mapNode = XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());\n                if (xmlns) {\n                    mapNode.addAttribute(xmlnsAttr, xmlns);\n                }\n                container.addChildNode(mapNode);\n            }\n            for (const [key, val] of Object.entries(map)) {\n                if (sparse || val != null) {\n                    const entry = XmlNode.of(\"entry\");\n                    addKeyValue(entry, key, val);\n                    (containerIsMap ? container : mapNode).addChildNode(entry);\n                }\n            }\n        }\n    }\n    writeSimple(_schema, value) {\n        if (null === value) {\n            throw new Error(\"@aws-sdk/core/protocols - (XML serializer) cannot write null value.\");\n        }\n        const ns = NormalizedSchema.of(_schema);\n        let nodeContents = null;\n        if (value && typeof value === \"object\") {\n            if (ns.isBlobSchema()) {\n                nodeContents = (this.serdeContext?.base64Encoder ?? toBase64)(value);\n            }\n            else if (ns.isTimestampSchema() && value instanceof Date) {\n                const format = determineTimestampFormat(ns, this.settings);\n                switch (format) {\n                    case 5:\n                        nodeContents = value.toISOString().replace(\".000Z\", \"Z\");\n                        break;\n                    case 6:\n                        nodeContents = dateToUtcString(value);\n                        break;\n                    case 7:\n                        nodeContents = String(value.getTime() / 1000);\n                        break;\n                    default:\n                        console.warn(\"Missing timestamp format, using http date\", value);\n                        nodeContents = dateToUtcString(value);\n                        break;\n                }\n            }\n            else if (ns.isBigDecimalSchema() && value) {\n                if (value instanceof NumericValue) {\n                    return value.string;\n                }\n                return String(value);\n            }\n            else if (ns.isMapSchema() || ns.isListSchema()) {\n                throw new Error(\"@aws-sdk/core/protocols - xml serializer, cannot call _write() on List/Map schema, call writeList or writeMap() instead.\");\n            }\n            else {\n                throw new Error(`@aws-sdk/core/protocols - xml serializer, unhandled schema type for object value and schema: ${ns.getName(true)}`);\n            }\n        }\n        if (ns.isBooleanSchema() || ns.isNumericSchema() || ns.isBigIntegerSchema() || ns.isBigDecimalSchema()) {\n            nodeContents = String(value);\n        }\n        if (ns.isStringSchema()) {\n            if (value === undefined && ns.isIdempotencyToken()) {\n                nodeContents = generateIdempotencyToken();\n            }\n            else {\n                nodeContents = String(value);\n            }\n        }\n        if (nodeContents === null) {\n            throw new Error(`Unhandled schema-value pair ${ns.getName(true)}=${value}`);\n        }\n        return nodeContents;\n    }\n    writeSimpleInto(_schema, value, into, parentXmlns) {\n        const nodeContents = this.writeSimple(_schema, value);\n        const ns = NormalizedSchema.of(_schema);\n        const content = new XmlText(nodeContents);\n        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);\n        if (xmlns) {\n            into.addAttribute(xmlnsAttr, xmlns);\n        }\n        into.addChildNode(content);\n    }\n    getXmlnsAttribute(ns, parentXmlns) {\n        const traits = ns.getMergedTraits();\n        const [prefix, xmlns] = traits.xmlNamespace ?? [];\n        if (xmlns && xmlns !== parentXmlns) {\n            return [prefix ? `xmlns:${prefix}` : \"xmlns\", xmlns];\n        }\n        return [void 0, void 0];\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}