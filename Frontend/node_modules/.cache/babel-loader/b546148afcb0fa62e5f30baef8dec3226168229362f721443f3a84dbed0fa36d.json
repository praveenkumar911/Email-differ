{"ast":null,"code":"import isViablePhoneNumber from '../helpers/isViablePhoneNumber.js';\nimport parseNumber from '../parse.js';\nimport _isValidNumberForRegion from './isValidNumberForRegion_.js';\n\n// This function has been deprecated and is not exported as\n// `isValidPhoneNumberForCountry()` or `isValidPhoneNumberForRegion()`.\n//\n// The rationale is:\n//\n// * We don't use the \"region\" word, so \"country\" would be better.\n//\n// * It could be substituted with:\n//\n// ```js\n// export default function isValidPhoneNumberForCountry(phoneNumberString, country) {\n// \tconst phoneNumber = parsePhoneNumber(phoneNumberString, {\n// \t\tdefaultCountry: country,\n// \t\t// Demand that the entire input string must be a phone number.\n// \t\t// Otherwise, it would \"extract\" a phone number from an input string.\n// \t\textract: false\n// \t})\n// \tif (!phoneNumber) {\n// \t\treturn false\n// \t}\n// \tif (phoneNumber.country !== country) {\n// \t\treturn false\n// \t}\n// \treturn phoneNumber.isValid()\n// }\n// ```\n//\n// * Same function could be used for `isPossiblePhoneNumberForCountry()`\n//   by replacing `isValid()` with `isPossible()`.\n//\n// * The reason why this function is not exported is because its result is ambiguous.\n//   Suppose `false` is returned. It could mean any of:\n//   * Not a phone number.\n//   * The phone number is valid but belongs to another country or another calling code.\n//   * The phone number belongs to the correct country but is not valid digit-wise.\n//   All those three cases should be handled separately from a \"User Experience\" standpoint.\n//   Simply showing \"Invalid phone number\" error in all of those cases would be lazy UX.\n\nexport default function isValidNumberForRegion(number, country, metadata) {\n  if (typeof number !== 'string') {\n    throw new TypeError('number must be a string');\n  }\n  if (typeof country !== 'string') {\n    throw new TypeError('country must be a string');\n  }\n  // `parse` extracts phone numbers from raw text,\n  // therefore it will cut off all \"garbage\" characters,\n  // while this `validate` function needs to verify\n  // that the phone number contains no \"garbage\"\n  // therefore the explicit `isViablePhoneNumber` check.\n  var input;\n  if (isViablePhoneNumber(number)) {\n    input = parseNumber(number, {\n      defaultCountry: country\n    }, metadata);\n  } else {\n    input = {};\n  }\n  return _isValidNumberForRegion(input, country, undefined, metadata);\n}","map":{"version":3,"names":["isViablePhoneNumber","parseNumber","_isValidNumberForRegion","isValidNumberForRegion","number","country","metadata","TypeError","input","defaultCountry","undefined"],"sources":["/home/rcts/Email-differ/Frontend/node_modules/libphonenumber-js/source/legacy/isValidNumberForRegion.js"],"sourcesContent":["import isViablePhoneNumber from '../helpers/isViablePhoneNumber.js'\r\nimport parseNumber from '../parse.js'\r\nimport _isValidNumberForRegion from './isValidNumberForRegion_.js'\r\n\r\n// This function has been deprecated and is not exported as\r\n// `isValidPhoneNumberForCountry()` or `isValidPhoneNumberForRegion()`.\r\n//\r\n// The rationale is:\r\n//\r\n// * We don't use the \"region\" word, so \"country\" would be better.\r\n//\r\n// * It could be substituted with:\r\n//\r\n// ```js\r\n// export default function isValidPhoneNumberForCountry(phoneNumberString, country) {\r\n// \tconst phoneNumber = parsePhoneNumber(phoneNumberString, {\r\n// \t\tdefaultCountry: country,\r\n// \t\t// Demand that the entire input string must be a phone number.\r\n// \t\t// Otherwise, it would \"extract\" a phone number from an input string.\r\n// \t\textract: false\r\n// \t})\r\n// \tif (!phoneNumber) {\r\n// \t\treturn false\r\n// \t}\r\n// \tif (phoneNumber.country !== country) {\r\n// \t\treturn false\r\n// \t}\r\n// \treturn phoneNumber.isValid()\r\n// }\r\n// ```\r\n//\r\n// * Same function could be used for `isPossiblePhoneNumberForCountry()`\r\n//   by replacing `isValid()` with `isPossible()`.\r\n//\r\n// * The reason why this function is not exported is because its result is ambiguous.\r\n//   Suppose `false` is returned. It could mean any of:\r\n//   * Not a phone number.\r\n//   * The phone number is valid but belongs to another country or another calling code.\r\n//   * The phone number belongs to the correct country but is not valid digit-wise.\r\n//   All those three cases should be handled separately from a \"User Experience\" standpoint.\r\n//   Simply showing \"Invalid phone number\" error in all of those cases would be lazy UX.\r\n\r\nexport default function isValidNumberForRegion(number, country, metadata) {\r\n\tif (typeof number !== 'string') {\r\n\t\tthrow new TypeError('number must be a string')\r\n\t}\r\n\tif (typeof country !== 'string') {\r\n\t\tthrow new TypeError('country must be a string')\r\n\t}\r\n\t// `parse` extracts phone numbers from raw text,\r\n\t// therefore it will cut off all \"garbage\" characters,\r\n\t// while this `validate` function needs to verify\r\n\t// that the phone number contains no \"garbage\"\r\n\t// therefore the explicit `isViablePhoneNumber` check.\r\n\tlet input\r\n\tif (isViablePhoneNumber(number)) {\r\n\t\tinput = parseNumber(number, { defaultCountry: country }, metadata)\r\n\t} else {\r\n\t\tinput = {}\r\n\t}\r\n\treturn _isValidNumberForRegion(input, country, undefined, metadata)\r\n}"],"mappings":"AAAA,OAAOA,mBAAmB,MAAM,mCAAmC;AACnE,OAAOC,WAAW,MAAM,aAAa;AACrC,OAAOC,uBAAuB,MAAM,8BAA8B;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,SAASC,sBAAsBA,CAACC,MAAM,EAAEC,OAAO,EAAEC,QAAQ,EAAE;EACzE,IAAI,OAAOF,MAAM,KAAK,QAAQ,EAAE;IAC/B,MAAM,IAAIG,SAAS,CAAC,yBAAyB,CAAC;EAC/C;EACA,IAAI,OAAOF,OAAO,KAAK,QAAQ,EAAE;IAChC,MAAM,IAAIE,SAAS,CAAC,0BAA0B,CAAC;EAChD;EACA;EACA;EACA;EACA;EACA;EACA,IAAIC,KAAK;EACT,IAAIR,mBAAmB,CAACI,MAAM,CAAC,EAAE;IAChCI,KAAK,GAAGP,WAAW,CAACG,MAAM,EAAE;MAAEK,cAAc,EAAEJ;IAAQ,CAAC,EAAEC,QAAQ,CAAC;EACnE,CAAC,MAAM;IACNE,KAAK,GAAG,CAAC,CAAC;EACX;EACA,OAAON,uBAAuB,CAACM,KAAK,EAAEH,OAAO,EAAEK,SAAS,EAAEJ,QAAQ,CAAC;AACpE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}