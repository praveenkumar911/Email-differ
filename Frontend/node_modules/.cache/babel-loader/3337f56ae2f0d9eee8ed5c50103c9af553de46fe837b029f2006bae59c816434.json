{"ast":null,"code":"import _objectSpread from \"/home/rcts/Email-differ/Frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"/home/rcts/Email-differ/Frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { deref } from \"../deref\";\nimport { translateTraits } from \"./translateTraits\";\nexport class NormalizedSchema {\n  constructor(ref, memberName) {\n    _defineProperty(this, \"ref\", void 0);\n    _defineProperty(this, \"memberName\", void 0);\n    _defineProperty(this, \"symbol\", NormalizedSchema.symbol);\n    _defineProperty(this, \"name\", void 0);\n    _defineProperty(this, \"schema\", void 0);\n    _defineProperty(this, \"_isMemberSchema\", void 0);\n    _defineProperty(this, \"traits\", void 0);\n    _defineProperty(this, \"memberTraits\", void 0);\n    _defineProperty(this, \"normalizedTraits\", void 0);\n    this.ref = ref;\n    this.memberName = memberName;\n    const traitStack = [];\n    let _ref = ref;\n    let schema = ref;\n    this._isMemberSchema = false;\n    while (isMemberSchema(_ref)) {\n      traitStack.push(_ref[1]);\n      _ref = _ref[0];\n      schema = deref(_ref);\n      this._isMemberSchema = true;\n    }\n    if (traitStack.length > 0) {\n      this.memberTraits = {};\n      for (let i = traitStack.length - 1; i >= 0; --i) {\n        const traitSet = traitStack[i];\n        Object.assign(this.memberTraits, translateTraits(traitSet));\n      }\n    } else {\n      this.memberTraits = 0;\n    }\n    if (schema instanceof NormalizedSchema) {\n      const computedMemberTraits = this.memberTraits;\n      Object.assign(this, schema);\n      this.memberTraits = Object.assign({}, computedMemberTraits, schema.getMemberTraits(), this.getMemberTraits());\n      this.normalizedTraits = void 0;\n      this.memberName = memberName !== null && memberName !== void 0 ? memberName : schema.memberName;\n      return;\n    }\n    this.schema = deref(schema);\n    if (isStaticSchema(this.schema)) {\n      this.name = \"\".concat(this.schema[1], \"#\").concat(this.schema[2]);\n      this.traits = this.schema[3];\n    } else {\n      var _this$memberName;\n      this.name = (_this$memberName = this.memberName) !== null && _this$memberName !== void 0 ? _this$memberName : String(schema);\n      this.traits = 0;\n    }\n    if (this._isMemberSchema && !memberName) {\n      throw new Error(\"@smithy/core/schema - NormalizedSchema member init \".concat(this.getName(true), \" missing member name.\"));\n    }\n  }\n  static [Symbol.hasInstance](lhs) {\n    const isPrototype = this.prototype.isPrototypeOf(lhs);\n    if (!isPrototype && typeof lhs === \"object\" && lhs !== null) {\n      const ns = lhs;\n      return ns.symbol === this.symbol;\n    }\n    return isPrototype;\n  }\n  static of(ref) {\n    const sc = deref(ref);\n    if (sc instanceof NormalizedSchema) {\n      return sc;\n    }\n    if (isMemberSchema(sc)) {\n      const [ns, traits] = sc;\n      if (ns instanceof NormalizedSchema) {\n        Object.assign(ns.getMergedTraits(), translateTraits(traits));\n        return ns;\n      }\n      throw new Error(\"@smithy/core/schema - may not init unwrapped member schema=\".concat(JSON.stringify(ref, null, 2), \".\"));\n    }\n    return new NormalizedSchema(sc);\n  }\n  getSchema() {\n    const sc = this.schema;\n    if (sc[0] === 0) {\n      return sc[4];\n    }\n    return sc;\n  }\n  getName() {\n    let withNamespace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const {\n      name\n    } = this;\n    const short = !withNamespace && name && name.includes(\"#\");\n    return short ? name.split(\"#\")[1] : name || undefined;\n  }\n  getMemberName() {\n    return this.memberName;\n  }\n  isMemberSchema() {\n    return this._isMemberSchema;\n  }\n  isListSchema() {\n    const sc = this.getSchema();\n    return typeof sc === \"number\" ? sc >= 64 && sc < 128 : sc[0] === 1;\n  }\n  isMapSchema() {\n    const sc = this.getSchema();\n    return typeof sc === \"number\" ? sc >= 128 && sc <= 0b11111111 : sc[0] === 2;\n  }\n  isStructSchema() {\n    const sc = this.getSchema();\n    const id = sc[0];\n    return id === 3 || id === -3 || id === 4;\n  }\n  isUnionSchema() {\n    const sc = this.getSchema();\n    return sc[0] === 4;\n  }\n  isBlobSchema() {\n    const sc = this.getSchema();\n    return sc === 21 || sc === 42;\n  }\n  isTimestampSchema() {\n    const sc = this.getSchema();\n    return typeof sc === \"number\" && sc >= 4 && sc <= 7;\n  }\n  isUnitSchema() {\n    return this.getSchema() === \"unit\";\n  }\n  isDocumentSchema() {\n    return this.getSchema() === 15;\n  }\n  isStringSchema() {\n    return this.getSchema() === 0;\n  }\n  isBooleanSchema() {\n    return this.getSchema() === 2;\n  }\n  isNumericSchema() {\n    return this.getSchema() === 1;\n  }\n  isBigIntegerSchema() {\n    return this.getSchema() === 17;\n  }\n  isBigDecimalSchema() {\n    return this.getSchema() === 19;\n  }\n  isStreaming() {\n    const {\n      streaming\n    } = this.getMergedTraits();\n    return !!streaming || this.getSchema() === 42;\n  }\n  isIdempotencyToken() {\n    const match = traits => (traits & 0b0100) === 0b0100 || !!(traits !== null && traits !== void 0 && traits.idempotencyToken);\n    const {\n      normalizedTraits,\n      traits,\n      memberTraits\n    } = this;\n    return match(normalizedTraits) || match(traits) || match(memberTraits);\n  }\n  getMergedTraits() {\n    var _this$normalizedTrait;\n    return (_this$normalizedTrait = this.normalizedTraits) !== null && _this$normalizedTrait !== void 0 ? _this$normalizedTrait : this.normalizedTraits = _objectSpread(_objectSpread({}, this.getOwnTraits()), this.getMemberTraits());\n  }\n  getMemberTraits() {\n    return translateTraits(this.memberTraits);\n  }\n  getOwnTraits() {\n    return translateTraits(this.traits);\n  }\n  getKeySchema() {\n    var _schema$;\n    const [isDoc, isMap] = [this.isDocumentSchema(), this.isMapSchema()];\n    if (!isDoc && !isMap) {\n      throw new Error(\"@smithy/core/schema - cannot get key for non-map: \".concat(this.getName(true)));\n    }\n    const schema = this.getSchema();\n    const memberSchema = isDoc ? 15 : (_schema$ = schema[4]) !== null && _schema$ !== void 0 ? _schema$ : 0;\n    return member([memberSchema, 0], \"key\");\n  }\n  getValueSchema() {\n    const sc = this.getSchema();\n    const [isDoc, isMap, isList] = [this.isDocumentSchema(), this.isMapSchema(), this.isListSchema()];\n    const memberSchema = typeof sc === \"number\" ? 0b00111111 & sc : sc && typeof sc === \"object\" && (isMap || isList) ? sc[3 + sc[0]] : isDoc ? 15 : void 0;\n    if (memberSchema != null) {\n      return member([memberSchema, 0], isMap ? \"value\" : \"member\");\n    }\n    throw new Error(\"@smithy/core/schema - \".concat(this.getName(true), \" has no value member.\"));\n  }\n  getMemberSchema(memberName) {\n    const struct = this.getSchema();\n    if (this.isStructSchema() && struct[4].includes(memberName)) {\n      const i = struct[4].indexOf(memberName);\n      const memberSchema = struct[5][i];\n      return member(isMemberSchema(memberSchema) ? memberSchema : [memberSchema, 0], memberName);\n    }\n    if (this.isDocumentSchema()) {\n      return member([15, 0], memberName);\n    }\n    throw new Error(\"@smithy/core/schema - \".concat(this.getName(true), \" has no no member=\").concat(memberName, \".\"));\n  }\n  getMemberSchemas() {\n    const buffer = {};\n    try {\n      for (const [k, v] of this.structIterator()) {\n        buffer[k] = v;\n      }\n    } catch (ignored) {}\n    return buffer;\n  }\n  getEventStreamMember() {\n    if (this.isStructSchema()) {\n      for (const [memberName, memberSchema] of this.structIterator()) {\n        if (memberSchema.isStreaming() && memberSchema.isStructSchema()) {\n          return memberName;\n        }\n      }\n    }\n    return \"\";\n  }\n  *structIterator() {\n    if (this.isUnitSchema()) {\n      return;\n    }\n    if (!this.isStructSchema()) {\n      throw new Error(\"@smithy/core/schema - cannot iterate non-struct schema.\");\n    }\n    const struct = this.getSchema();\n    for (let i = 0; i < struct[4].length; ++i) {\n      yield [struct[4][i], member([struct[5][i], 0], struct[4][i])];\n    }\n  }\n}\n_defineProperty(NormalizedSchema, \"symbol\", Symbol.for(\"@smithy/nor\"));\nfunction member(memberSchema, memberName) {\n  if (memberSchema instanceof NormalizedSchema) {\n    return Object.assign(memberSchema, {\n      memberName,\n      _isMemberSchema: true\n    });\n  }\n  const internalCtorAccess = NormalizedSchema;\n  return new internalCtorAccess(memberSchema, memberName);\n}\nconst isMemberSchema = sc => Array.isArray(sc) && sc.length === 2;\nexport const isStaticSchema = sc => Array.isArray(sc) && sc.length >= 5;","map":{"version":3,"names":["deref","translateTraits","NormalizedSchema","constructor","ref","memberName","_defineProperty","symbol","traitStack","_ref","schema","_isMemberSchema","isMemberSchema","push","length","memberTraits","i","traitSet","Object","assign","computedMemberTraits","getMemberTraits","normalizedTraits","isStaticSchema","name","concat","traits","_this$memberName","String","Error","getName","Symbol","hasInstance","lhs","isPrototype","prototype","isPrototypeOf","ns","of","sc","getMergedTraits","JSON","stringify","getSchema","withNamespace","arguments","undefined","short","includes","split","getMemberName","isListSchema","isMapSchema","isStructSchema","id","isUnionSchema","isBlobSchema","isTimestampSchema","isUnitSchema","isDocumentSchema","isStringSchema","isBooleanSchema","isNumericSchema","isBigIntegerSchema","isBigDecimalSchema","isStreaming","streaming","isIdempotencyToken","match","idempotencyToken","_this$normalizedTrait","_objectSpread","getOwnTraits","getKeySchema","_schema$","isDoc","isMap","memberSchema","member","getValueSchema","isList","getMemberSchema","struct","indexOf","getMemberSchemas","buffer","k","v","structIterator","ignored","getEventStreamMember","for","internalCtorAccess","Array","isArray"],"sources":["/home/rcts/Email-differ/Frontend/node_modules/@smithy/core/dist-es/submodules/schema/schemas/NormalizedSchema.js"],"sourcesContent":["import { deref } from \"../deref\";\nimport { translateTraits } from \"./translateTraits\";\nexport class NormalizedSchema {\n    ref;\n    memberName;\n    static symbol = Symbol.for(\"@smithy/nor\");\n    symbol = NormalizedSchema.symbol;\n    name;\n    schema;\n    _isMemberSchema;\n    traits;\n    memberTraits;\n    normalizedTraits;\n    constructor(ref, memberName) {\n        this.ref = ref;\n        this.memberName = memberName;\n        const traitStack = [];\n        let _ref = ref;\n        let schema = ref;\n        this._isMemberSchema = false;\n        while (isMemberSchema(_ref)) {\n            traitStack.push(_ref[1]);\n            _ref = _ref[0];\n            schema = deref(_ref);\n            this._isMemberSchema = true;\n        }\n        if (traitStack.length > 0) {\n            this.memberTraits = {};\n            for (let i = traitStack.length - 1; i >= 0; --i) {\n                const traitSet = traitStack[i];\n                Object.assign(this.memberTraits, translateTraits(traitSet));\n            }\n        }\n        else {\n            this.memberTraits = 0;\n        }\n        if (schema instanceof NormalizedSchema) {\n            const computedMemberTraits = this.memberTraits;\n            Object.assign(this, schema);\n            this.memberTraits = Object.assign({}, computedMemberTraits, schema.getMemberTraits(), this.getMemberTraits());\n            this.normalizedTraits = void 0;\n            this.memberName = memberName ?? schema.memberName;\n            return;\n        }\n        this.schema = deref(schema);\n        if (isStaticSchema(this.schema)) {\n            this.name = `${this.schema[1]}#${this.schema[2]}`;\n            this.traits = this.schema[3];\n        }\n        else {\n            this.name = this.memberName ?? String(schema);\n            this.traits = 0;\n        }\n        if (this._isMemberSchema && !memberName) {\n            throw new Error(`@smithy/core/schema - NormalizedSchema member init ${this.getName(true)} missing member name.`);\n        }\n    }\n    static [Symbol.hasInstance](lhs) {\n        const isPrototype = this.prototype.isPrototypeOf(lhs);\n        if (!isPrototype && typeof lhs === \"object\" && lhs !== null) {\n            const ns = lhs;\n            return ns.symbol === this.symbol;\n        }\n        return isPrototype;\n    }\n    static of(ref) {\n        const sc = deref(ref);\n        if (sc instanceof NormalizedSchema) {\n            return sc;\n        }\n        if (isMemberSchema(sc)) {\n            const [ns, traits] = sc;\n            if (ns instanceof NormalizedSchema) {\n                Object.assign(ns.getMergedTraits(), translateTraits(traits));\n                return ns;\n            }\n            throw new Error(`@smithy/core/schema - may not init unwrapped member schema=${JSON.stringify(ref, null, 2)}.`);\n        }\n        return new NormalizedSchema(sc);\n    }\n    getSchema() {\n        const sc = this.schema;\n        if (sc[0] === 0) {\n            return sc[4];\n        }\n        return sc;\n    }\n    getName(withNamespace = false) {\n        const { name } = this;\n        const short = !withNamespace && name && name.includes(\"#\");\n        return short ? name.split(\"#\")[1] : name || undefined;\n    }\n    getMemberName() {\n        return this.memberName;\n    }\n    isMemberSchema() {\n        return this._isMemberSchema;\n    }\n    isListSchema() {\n        const sc = this.getSchema();\n        return typeof sc === \"number\"\n            ? sc >= 64 && sc < 128\n            : sc[0] === 1;\n    }\n    isMapSchema() {\n        const sc = this.getSchema();\n        return typeof sc === \"number\"\n            ? sc >= 128 && sc <= 0b1111_1111\n            : sc[0] === 2;\n    }\n    isStructSchema() {\n        const sc = this.getSchema();\n        const id = sc[0];\n        return (id === 3 ||\n            id === -3 ||\n            id === 4);\n    }\n    isUnionSchema() {\n        const sc = this.getSchema();\n        return sc[0] === 4;\n    }\n    isBlobSchema() {\n        const sc = this.getSchema();\n        return sc === 21 || sc === 42;\n    }\n    isTimestampSchema() {\n        const sc = this.getSchema();\n        return (typeof sc === \"number\" &&\n            sc >= 4 &&\n            sc <= 7);\n    }\n    isUnitSchema() {\n        return this.getSchema() === \"unit\";\n    }\n    isDocumentSchema() {\n        return this.getSchema() === 15;\n    }\n    isStringSchema() {\n        return this.getSchema() === 0;\n    }\n    isBooleanSchema() {\n        return this.getSchema() === 2;\n    }\n    isNumericSchema() {\n        return this.getSchema() === 1;\n    }\n    isBigIntegerSchema() {\n        return this.getSchema() === 17;\n    }\n    isBigDecimalSchema() {\n        return this.getSchema() === 19;\n    }\n    isStreaming() {\n        const { streaming } = this.getMergedTraits();\n        return !!streaming || this.getSchema() === 42;\n    }\n    isIdempotencyToken() {\n        const match = (traits) => (traits & 0b0100) === 0b0100 ||\n            !!traits?.idempotencyToken;\n        const { normalizedTraits, traits, memberTraits } = this;\n        return match(normalizedTraits) || match(traits) || match(memberTraits);\n    }\n    getMergedTraits() {\n        return (this.normalizedTraits ??\n            (this.normalizedTraits = {\n                ...this.getOwnTraits(),\n                ...this.getMemberTraits(),\n            }));\n    }\n    getMemberTraits() {\n        return translateTraits(this.memberTraits);\n    }\n    getOwnTraits() {\n        return translateTraits(this.traits);\n    }\n    getKeySchema() {\n        const [isDoc, isMap] = [this.isDocumentSchema(), this.isMapSchema()];\n        if (!isDoc && !isMap) {\n            throw new Error(`@smithy/core/schema - cannot get key for non-map: ${this.getName(true)}`);\n        }\n        const schema = this.getSchema();\n        const memberSchema = isDoc\n            ? 15\n            : schema[4] ?? 0;\n        return member([memberSchema, 0], \"key\");\n    }\n    getValueSchema() {\n        const sc = this.getSchema();\n        const [isDoc, isMap, isList] = [this.isDocumentSchema(), this.isMapSchema(), this.isListSchema()];\n        const memberSchema = typeof sc === \"number\"\n            ? 0b0011_1111 & sc\n            : sc && typeof sc === \"object\" && (isMap || isList)\n                ? sc[3 + sc[0]]\n                : isDoc\n                    ? 15\n                    : void 0;\n        if (memberSchema != null) {\n            return member([memberSchema, 0], isMap ? \"value\" : \"member\");\n        }\n        throw new Error(`@smithy/core/schema - ${this.getName(true)} has no value member.`);\n    }\n    getMemberSchema(memberName) {\n        const struct = this.getSchema();\n        if (this.isStructSchema() && struct[4].includes(memberName)) {\n            const i = struct[4].indexOf(memberName);\n            const memberSchema = struct[5][i];\n            return member(isMemberSchema(memberSchema) ? memberSchema : [memberSchema, 0], memberName);\n        }\n        if (this.isDocumentSchema()) {\n            return member([15, 0], memberName);\n        }\n        throw new Error(`@smithy/core/schema - ${this.getName(true)} has no no member=${memberName}.`);\n    }\n    getMemberSchemas() {\n        const buffer = {};\n        try {\n            for (const [k, v] of this.structIterator()) {\n                buffer[k] = v;\n            }\n        }\n        catch (ignored) { }\n        return buffer;\n    }\n    getEventStreamMember() {\n        if (this.isStructSchema()) {\n            for (const [memberName, memberSchema] of this.structIterator()) {\n                if (memberSchema.isStreaming() && memberSchema.isStructSchema()) {\n                    return memberName;\n                }\n            }\n        }\n        return \"\";\n    }\n    *structIterator() {\n        if (this.isUnitSchema()) {\n            return;\n        }\n        if (!this.isStructSchema()) {\n            throw new Error(\"@smithy/core/schema - cannot iterate non-struct schema.\");\n        }\n        const struct = this.getSchema();\n        for (let i = 0; i < struct[4].length; ++i) {\n            yield [struct[4][i], member([struct[5][i], 0], struct[4][i])];\n        }\n    }\n}\nfunction member(memberSchema, memberName) {\n    if (memberSchema instanceof NormalizedSchema) {\n        return Object.assign(memberSchema, {\n            memberName,\n            _isMemberSchema: true,\n        });\n    }\n    const internalCtorAccess = NormalizedSchema;\n    return new internalCtorAccess(memberSchema, memberName);\n}\nconst isMemberSchema = (sc) => Array.isArray(sc) && sc.length === 2;\nexport const isStaticSchema = (sc) => Array.isArray(sc) && sc.length >= 5;\n"],"mappings":";;AAAA,SAASA,KAAK,QAAQ,UAAU;AAChC,SAASC,eAAe,QAAQ,mBAAmB;AACnD,OAAO,MAAMC,gBAAgB,CAAC;EAW1BC,WAAWA,CAACC,GAAG,EAAEC,UAAU,EAAE;IAAAC,eAAA;IAAAA,eAAA;IAAAA,eAAA,iBAPpBJ,gBAAgB,CAACK,MAAM;IAAAD,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAQ5B,IAAI,CAACF,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,MAAMG,UAAU,GAAG,EAAE;IACrB,IAAIC,IAAI,GAAGL,GAAG;IACd,IAAIM,MAAM,GAAGN,GAAG;IAChB,IAAI,CAACO,eAAe,GAAG,KAAK;IAC5B,OAAOC,cAAc,CAACH,IAAI,CAAC,EAAE;MACzBD,UAAU,CAACK,IAAI,CAACJ,IAAI,CAAC,CAAC,CAAC,CAAC;MACxBA,IAAI,GAAGA,IAAI,CAAC,CAAC,CAAC;MACdC,MAAM,GAAGV,KAAK,CAACS,IAAI,CAAC;MACpB,IAAI,CAACE,eAAe,GAAG,IAAI;IAC/B;IACA,IAAIH,UAAU,CAACM,MAAM,GAAG,CAAC,EAAE;MACvB,IAAI,CAACC,YAAY,GAAG,CAAC,CAAC;MACtB,KAAK,IAAIC,CAAC,GAAGR,UAAU,CAACM,MAAM,GAAG,CAAC,EAAEE,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;QAC7C,MAAMC,QAAQ,GAAGT,UAAU,CAACQ,CAAC,CAAC;QAC9BE,MAAM,CAACC,MAAM,CAAC,IAAI,CAACJ,YAAY,EAAEd,eAAe,CAACgB,QAAQ,CAAC,CAAC;MAC/D;IACJ,CAAC,MACI;MACD,IAAI,CAACF,YAAY,GAAG,CAAC;IACzB;IACA,IAAIL,MAAM,YAAYR,gBAAgB,EAAE;MACpC,MAAMkB,oBAAoB,GAAG,IAAI,CAACL,YAAY;MAC9CG,MAAM,CAACC,MAAM,CAAC,IAAI,EAAET,MAAM,CAAC;MAC3B,IAAI,CAACK,YAAY,GAAGG,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEC,oBAAoB,EAAEV,MAAM,CAACW,eAAe,CAAC,CAAC,EAAE,IAAI,CAACA,eAAe,CAAC,CAAC,CAAC;MAC7G,IAAI,CAACC,gBAAgB,GAAG,KAAK,CAAC;MAC9B,IAAI,CAACjB,UAAU,GAAGA,UAAU,aAAVA,UAAU,cAAVA,UAAU,GAAIK,MAAM,CAACL,UAAU;MACjD;IACJ;IACA,IAAI,CAACK,MAAM,GAAGV,KAAK,CAACU,MAAM,CAAC;IAC3B,IAAIa,cAAc,CAAC,IAAI,CAACb,MAAM,CAAC,EAAE;MAC7B,IAAI,CAACc,IAAI,MAAAC,MAAA,CAAM,IAAI,CAACf,MAAM,CAAC,CAAC,CAAC,OAAAe,MAAA,CAAI,IAAI,CAACf,MAAM,CAAC,CAAC,CAAC,CAAE;MACjD,IAAI,CAACgB,MAAM,GAAG,IAAI,CAAChB,MAAM,CAAC,CAAC,CAAC;IAChC,CAAC,MACI;MAAA,IAAAiB,gBAAA;MACD,IAAI,CAACH,IAAI,IAAAG,gBAAA,GAAG,IAAI,CAACtB,UAAU,cAAAsB,gBAAA,cAAAA,gBAAA,GAAIC,MAAM,CAAClB,MAAM,CAAC;MAC7C,IAAI,CAACgB,MAAM,GAAG,CAAC;IACnB;IACA,IAAI,IAAI,CAACf,eAAe,IAAI,CAACN,UAAU,EAAE;MACrC,MAAM,IAAIwB,KAAK,uDAAAJ,MAAA,CAAuD,IAAI,CAACK,OAAO,CAAC,IAAI,CAAC,0BAAuB,CAAC;IACpH;EACJ;EACA,QAAQC,MAAM,CAACC,WAAW,EAAEC,GAAG,EAAE;IAC7B,MAAMC,WAAW,GAAG,IAAI,CAACC,SAAS,CAACC,aAAa,CAACH,GAAG,CAAC;IACrD,IAAI,CAACC,WAAW,IAAI,OAAOD,GAAG,KAAK,QAAQ,IAAIA,GAAG,KAAK,IAAI,EAAE;MACzD,MAAMI,EAAE,GAAGJ,GAAG;MACd,OAAOI,EAAE,CAAC9B,MAAM,KAAK,IAAI,CAACA,MAAM;IACpC;IACA,OAAO2B,WAAW;EACtB;EACA,OAAOI,EAAEA,CAAClC,GAAG,EAAE;IACX,MAAMmC,EAAE,GAAGvC,KAAK,CAACI,GAAG,CAAC;IACrB,IAAImC,EAAE,YAAYrC,gBAAgB,EAAE;MAChC,OAAOqC,EAAE;IACb;IACA,IAAI3B,cAAc,CAAC2B,EAAE,CAAC,EAAE;MACpB,MAAM,CAACF,EAAE,EAAEX,MAAM,CAAC,GAAGa,EAAE;MACvB,IAAIF,EAAE,YAAYnC,gBAAgB,EAAE;QAChCgB,MAAM,CAACC,MAAM,CAACkB,EAAE,CAACG,eAAe,CAAC,CAAC,EAAEvC,eAAe,CAACyB,MAAM,CAAC,CAAC;QAC5D,OAAOW,EAAE;MACb;MACA,MAAM,IAAIR,KAAK,+DAAAJ,MAAA,CAA+DgB,IAAI,CAACC,SAAS,CAACtC,GAAG,EAAE,IAAI,EAAE,CAAC,CAAC,MAAG,CAAC;IAClH;IACA,OAAO,IAAIF,gBAAgB,CAACqC,EAAE,CAAC;EACnC;EACAI,SAASA,CAAA,EAAG;IACR,MAAMJ,EAAE,GAAG,IAAI,CAAC7B,MAAM;IACtB,IAAI6B,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;MACb,OAAOA,EAAE,CAAC,CAAC,CAAC;IAChB;IACA,OAAOA,EAAE;EACb;EACAT,OAAOA,CAAA,EAAwB;IAAA,IAAvBc,aAAa,GAAAC,SAAA,CAAA/B,MAAA,QAAA+B,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;IACzB,MAAM;MAAErB;IAAK,CAAC,GAAG,IAAI;IACrB,MAAMuB,KAAK,GAAG,CAACH,aAAa,IAAIpB,IAAI,IAAIA,IAAI,CAACwB,QAAQ,CAAC,GAAG,CAAC;IAC1D,OAAOD,KAAK,GAAGvB,IAAI,CAACyB,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAGzB,IAAI,IAAIsB,SAAS;EACzD;EACAI,aAAaA,CAAA,EAAG;IACZ,OAAO,IAAI,CAAC7C,UAAU;EAC1B;EACAO,cAAcA,CAAA,EAAG;IACb,OAAO,IAAI,CAACD,eAAe;EAC/B;EACAwC,YAAYA,CAAA,EAAG;IACX,MAAMZ,EAAE,GAAG,IAAI,CAACI,SAAS,CAAC,CAAC;IAC3B,OAAO,OAAOJ,EAAE,KAAK,QAAQ,GACvBA,EAAE,IAAI,EAAE,IAAIA,EAAE,GAAG,GAAG,GACpBA,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC;EACrB;EACAa,WAAWA,CAAA,EAAG;IACV,MAAMb,EAAE,GAAG,IAAI,CAACI,SAAS,CAAC,CAAC;IAC3B,OAAO,OAAOJ,EAAE,KAAK,QAAQ,GACvBA,EAAE,IAAI,GAAG,IAAIA,EAAE,IAAI,UAAW,GAC9BA,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC;EACrB;EACAc,cAAcA,CAAA,EAAG;IACb,MAAMd,EAAE,GAAG,IAAI,CAACI,SAAS,CAAC,CAAC;IAC3B,MAAMW,EAAE,GAAGf,EAAE,CAAC,CAAC,CAAC;IAChB,OAAQe,EAAE,KAAK,CAAC,IACZA,EAAE,KAAK,CAAC,CAAC,IACTA,EAAE,KAAK,CAAC;EAChB;EACAC,aAAaA,CAAA,EAAG;IACZ,MAAMhB,EAAE,GAAG,IAAI,CAACI,SAAS,CAAC,CAAC;IAC3B,OAAOJ,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC;EACtB;EACAiB,YAAYA,CAAA,EAAG;IACX,MAAMjB,EAAE,GAAG,IAAI,CAACI,SAAS,CAAC,CAAC;IAC3B,OAAOJ,EAAE,KAAK,EAAE,IAAIA,EAAE,KAAK,EAAE;EACjC;EACAkB,iBAAiBA,CAAA,EAAG;IAChB,MAAMlB,EAAE,GAAG,IAAI,CAACI,SAAS,CAAC,CAAC;IAC3B,OAAQ,OAAOJ,EAAE,KAAK,QAAQ,IAC1BA,EAAE,IAAI,CAAC,IACPA,EAAE,IAAI,CAAC;EACf;EACAmB,YAAYA,CAAA,EAAG;IACX,OAAO,IAAI,CAACf,SAAS,CAAC,CAAC,KAAK,MAAM;EACtC;EACAgB,gBAAgBA,CAAA,EAAG;IACf,OAAO,IAAI,CAAChB,SAAS,CAAC,CAAC,KAAK,EAAE;EAClC;EACAiB,cAAcA,CAAA,EAAG;IACb,OAAO,IAAI,CAACjB,SAAS,CAAC,CAAC,KAAK,CAAC;EACjC;EACAkB,eAAeA,CAAA,EAAG;IACd,OAAO,IAAI,CAAClB,SAAS,CAAC,CAAC,KAAK,CAAC;EACjC;EACAmB,eAAeA,CAAA,EAAG;IACd,OAAO,IAAI,CAACnB,SAAS,CAAC,CAAC,KAAK,CAAC;EACjC;EACAoB,kBAAkBA,CAAA,EAAG;IACjB,OAAO,IAAI,CAACpB,SAAS,CAAC,CAAC,KAAK,EAAE;EAClC;EACAqB,kBAAkBA,CAAA,EAAG;IACjB,OAAO,IAAI,CAACrB,SAAS,CAAC,CAAC,KAAK,EAAE;EAClC;EACAsB,WAAWA,CAAA,EAAG;IACV,MAAM;MAAEC;IAAU,CAAC,GAAG,IAAI,CAAC1B,eAAe,CAAC,CAAC;IAC5C,OAAO,CAAC,CAAC0B,SAAS,IAAI,IAAI,CAACvB,SAAS,CAAC,CAAC,KAAK,EAAE;EACjD;EACAwB,kBAAkBA,CAAA,EAAG;IACjB,MAAMC,KAAK,GAAI1C,MAAM,IAAK,CAACA,MAAM,GAAG,MAAM,MAAM,MAAM,IAClD,CAAC,EAACA,MAAM,aAANA,MAAM,eAANA,MAAM,CAAE2C,gBAAgB;IAC9B,MAAM;MAAE/C,gBAAgB;MAAEI,MAAM;MAAEX;IAAa,CAAC,GAAG,IAAI;IACvD,OAAOqD,KAAK,CAAC9C,gBAAgB,CAAC,IAAI8C,KAAK,CAAC1C,MAAM,CAAC,IAAI0C,KAAK,CAACrD,YAAY,CAAC;EAC1E;EACAyB,eAAeA,CAAA,EAAG;IAAA,IAAA8B,qBAAA;IACd,QAAAA,qBAAA,GAAQ,IAAI,CAAChD,gBAAgB,cAAAgD,qBAAA,cAAAA,qBAAA,GACxB,IAAI,CAAChD,gBAAgB,GAAAiD,aAAA,CAAAA,aAAA,KACf,IAAI,CAACC,YAAY,CAAC,CAAC,GACnB,IAAI,CAACnD,eAAe,CAAC,CAAC,CAC5B;EACT;EACAA,eAAeA,CAAA,EAAG;IACd,OAAOpB,eAAe,CAAC,IAAI,CAACc,YAAY,CAAC;EAC7C;EACAyD,YAAYA,CAAA,EAAG;IACX,OAAOvE,eAAe,CAAC,IAAI,CAACyB,MAAM,CAAC;EACvC;EACA+C,YAAYA,CAAA,EAAG;IAAA,IAAAC,QAAA;IACX,MAAM,CAACC,KAAK,EAAEC,KAAK,CAAC,GAAG,CAAC,IAAI,CAACjB,gBAAgB,CAAC,CAAC,EAAE,IAAI,CAACP,WAAW,CAAC,CAAC,CAAC;IACpE,IAAI,CAACuB,KAAK,IAAI,CAACC,KAAK,EAAE;MAClB,MAAM,IAAI/C,KAAK,sDAAAJ,MAAA,CAAsD,IAAI,CAACK,OAAO,CAAC,IAAI,CAAC,CAAE,CAAC;IAC9F;IACA,MAAMpB,MAAM,GAAG,IAAI,CAACiC,SAAS,CAAC,CAAC;IAC/B,MAAMkC,YAAY,GAAGF,KAAK,GACpB,EAAE,IAAAD,QAAA,GACFhE,MAAM,CAAC,CAAC,CAAC,cAAAgE,QAAA,cAAAA,QAAA,GAAI,CAAC;IACpB,OAAOI,MAAM,CAAC,CAACD,YAAY,EAAE,CAAC,CAAC,EAAE,KAAK,CAAC;EAC3C;EACAE,cAAcA,CAAA,EAAG;IACb,MAAMxC,EAAE,GAAG,IAAI,CAACI,SAAS,CAAC,CAAC;IAC3B,MAAM,CAACgC,KAAK,EAAEC,KAAK,EAAEI,MAAM,CAAC,GAAG,CAAC,IAAI,CAACrB,gBAAgB,CAAC,CAAC,EAAE,IAAI,CAACP,WAAW,CAAC,CAAC,EAAE,IAAI,CAACD,YAAY,CAAC,CAAC,CAAC;IACjG,MAAM0B,YAAY,GAAG,OAAOtC,EAAE,KAAK,QAAQ,GACrC,UAAW,GAAGA,EAAE,GAChBA,EAAE,IAAI,OAAOA,EAAE,KAAK,QAAQ,KAAKqC,KAAK,IAAII,MAAM,CAAC,GAC7CzC,EAAE,CAAC,CAAC,GAAGA,EAAE,CAAC,CAAC,CAAC,CAAC,GACboC,KAAK,GACD,EAAE,GACF,KAAK,CAAC;IACpB,IAAIE,YAAY,IAAI,IAAI,EAAE;MACtB,OAAOC,MAAM,CAAC,CAACD,YAAY,EAAE,CAAC,CAAC,EAAED,KAAK,GAAG,OAAO,GAAG,QAAQ,CAAC;IAChE;IACA,MAAM,IAAI/C,KAAK,0BAAAJ,MAAA,CAA0B,IAAI,CAACK,OAAO,CAAC,IAAI,CAAC,0BAAuB,CAAC;EACvF;EACAmD,eAAeA,CAAC5E,UAAU,EAAE;IACxB,MAAM6E,MAAM,GAAG,IAAI,CAACvC,SAAS,CAAC,CAAC;IAC/B,IAAI,IAAI,CAACU,cAAc,CAAC,CAAC,IAAI6B,MAAM,CAAC,CAAC,CAAC,CAAClC,QAAQ,CAAC3C,UAAU,CAAC,EAAE;MACzD,MAAMW,CAAC,GAAGkE,MAAM,CAAC,CAAC,CAAC,CAACC,OAAO,CAAC9E,UAAU,CAAC;MACvC,MAAMwE,YAAY,GAAGK,MAAM,CAAC,CAAC,CAAC,CAAClE,CAAC,CAAC;MACjC,OAAO8D,MAAM,CAAClE,cAAc,CAACiE,YAAY,CAAC,GAAGA,YAAY,GAAG,CAACA,YAAY,EAAE,CAAC,CAAC,EAAExE,UAAU,CAAC;IAC9F;IACA,IAAI,IAAI,CAACsD,gBAAgB,CAAC,CAAC,EAAE;MACzB,OAAOmB,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAEzE,UAAU,CAAC;IACtC;IACA,MAAM,IAAIwB,KAAK,0BAAAJ,MAAA,CAA0B,IAAI,CAACK,OAAO,CAAC,IAAI,CAAC,wBAAAL,MAAA,CAAqBpB,UAAU,MAAG,CAAC;EAClG;EACA+E,gBAAgBA,CAAA,EAAG;IACf,MAAMC,MAAM,GAAG,CAAC,CAAC;IACjB,IAAI;MACA,KAAK,MAAM,CAACC,CAAC,EAAEC,CAAC,CAAC,IAAI,IAAI,CAACC,cAAc,CAAC,CAAC,EAAE;QACxCH,MAAM,CAACC,CAAC,CAAC,GAAGC,CAAC;MACjB;IACJ,CAAC,CACD,OAAOE,OAAO,EAAE,CAAE;IAClB,OAAOJ,MAAM;EACjB;EACAK,oBAAoBA,CAAA,EAAG;IACnB,IAAI,IAAI,CAACrC,cAAc,CAAC,CAAC,EAAE;MACvB,KAAK,MAAM,CAAChD,UAAU,EAAEwE,YAAY,CAAC,IAAI,IAAI,CAACW,cAAc,CAAC,CAAC,EAAE;QAC5D,IAAIX,YAAY,CAACZ,WAAW,CAAC,CAAC,IAAIY,YAAY,CAACxB,cAAc,CAAC,CAAC,EAAE;UAC7D,OAAOhD,UAAU;QACrB;MACJ;IACJ;IACA,OAAO,EAAE;EACb;EACA,CAACmF,cAAcA,CAAA,EAAG;IACd,IAAI,IAAI,CAAC9B,YAAY,CAAC,CAAC,EAAE;MACrB;IACJ;IACA,IAAI,CAAC,IAAI,CAACL,cAAc,CAAC,CAAC,EAAE;MACxB,MAAM,IAAIxB,KAAK,CAAC,yDAAyD,CAAC;IAC9E;IACA,MAAMqD,MAAM,GAAG,IAAI,CAACvC,SAAS,CAAC,CAAC;IAC/B,KAAK,IAAI3B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkE,MAAM,CAAC,CAAC,CAAC,CAACpE,MAAM,EAAE,EAAEE,CAAC,EAAE;MACvC,MAAM,CAACkE,MAAM,CAAC,CAAC,CAAC,CAAClE,CAAC,CAAC,EAAE8D,MAAM,CAAC,CAACI,MAAM,CAAC,CAAC,CAAC,CAAClE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEkE,MAAM,CAAC,CAAC,CAAC,CAAClE,CAAC,CAAC,CAAC,CAAC;IACjE;EACJ;AACJ;AAACV,eAAA,CAnPYJ,gBAAgB,YAGT6B,MAAM,CAAC4D,GAAG,CAAC,aAAa,CAAC;AAiP7C,SAASb,MAAMA,CAACD,YAAY,EAAExE,UAAU,EAAE;EACtC,IAAIwE,YAAY,YAAY3E,gBAAgB,EAAE;IAC1C,OAAOgB,MAAM,CAACC,MAAM,CAAC0D,YAAY,EAAE;MAC/BxE,UAAU;MACVM,eAAe,EAAE;IACrB,CAAC,CAAC;EACN;EACA,MAAMiF,kBAAkB,GAAG1F,gBAAgB;EAC3C,OAAO,IAAI0F,kBAAkB,CAACf,YAAY,EAAExE,UAAU,CAAC;AAC3D;AACA,MAAMO,cAAc,GAAI2B,EAAE,IAAKsD,KAAK,CAACC,OAAO,CAACvD,EAAE,CAAC,IAAIA,EAAE,CAACzB,MAAM,KAAK,CAAC;AACnE,OAAO,MAAMS,cAAc,GAAIgB,EAAE,IAAKsD,KAAK,CAACC,OAAO,CAACvD,EAAE,CAAC,IAAIA,EAAE,CAACzB,MAAM,IAAI,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}