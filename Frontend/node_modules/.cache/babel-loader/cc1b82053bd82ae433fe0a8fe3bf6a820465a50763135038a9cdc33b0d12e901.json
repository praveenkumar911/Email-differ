{"ast":null,"code":"import _defineProperty from \"/home/rcts/Email-differ/Frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { DEFAULT_MAX_ATTEMPTS, RETRY_MODES } from \"./config\";\nimport { DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS, NO_RETRY_INCREMENT, RETRY_COST, THROTTLING_RETRY_DELAY_BASE, TIMEOUT_RETRY_COST } from \"./constants\";\nimport { getDefaultRetryBackoffStrategy } from \"./defaultRetryBackoffStrategy\";\nimport { createDefaultRetryToken } from \"./defaultRetryToken\";\nexport class StandardRetryStrategy {\n  constructor(maxAttempts) {\n    _defineProperty(this, \"maxAttempts\", void 0);\n    _defineProperty(this, \"mode\", RETRY_MODES.STANDARD);\n    _defineProperty(this, \"capacity\", INITIAL_RETRY_TOKENS);\n    _defineProperty(this, \"retryBackoffStrategy\", getDefaultRetryBackoffStrategy());\n    _defineProperty(this, \"maxAttemptsProvider\", void 0);\n    this.maxAttempts = maxAttempts;\n    this.maxAttemptsProvider = typeof maxAttempts === \"function\" ? maxAttempts : async () => maxAttempts;\n  }\n  async acquireInitialRetryToken(retryTokenScope) {\n    return createDefaultRetryToken({\n      retryDelay: DEFAULT_RETRY_DELAY_BASE,\n      retryCount: 0\n    });\n  }\n  async refreshRetryTokenForRetry(token, errorInfo) {\n    const maxAttempts = await this.getMaxAttempts();\n    if (this.shouldRetry(token, errorInfo, maxAttempts)) {\n      const errorType = errorInfo.errorType;\n      this.retryBackoffStrategy.setDelayBase(errorType === \"THROTTLING\" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);\n      const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());\n      const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;\n      const capacityCost = this.getCapacityCost(errorType);\n      this.capacity -= capacityCost;\n      return createDefaultRetryToken({\n        retryDelay,\n        retryCount: token.getRetryCount() + 1,\n        retryCost: capacityCost\n      });\n    }\n    throw new Error(\"No retry token available\");\n  }\n  recordSuccess(token) {\n    var _token$getRetryCost;\n    this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + ((_token$getRetryCost = token.getRetryCost()) !== null && _token$getRetryCost !== void 0 ? _token$getRetryCost : NO_RETRY_INCREMENT));\n  }\n  getCapacity() {\n    return this.capacity;\n  }\n  async getMaxAttempts() {\n    try {\n      return await this.maxAttemptsProvider();\n    } catch (error) {\n      console.warn(\"Max attempts provider could not resolve. Using default of \".concat(DEFAULT_MAX_ATTEMPTS));\n      return DEFAULT_MAX_ATTEMPTS;\n    }\n  }\n  shouldRetry(tokenToRenew, errorInfo, maxAttempts) {\n    const attempts = tokenToRenew.getRetryCount() + 1;\n    return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);\n  }\n  getCapacityCost(errorType) {\n    return errorType === \"TRANSIENT\" ? TIMEOUT_RETRY_COST : RETRY_COST;\n  }\n  isRetryableError(errorType) {\n    return errorType === \"THROTTLING\" || errorType === \"TRANSIENT\";\n  }\n}","map":{"version":3,"names":["DEFAULT_MAX_ATTEMPTS","RETRY_MODES","DEFAULT_RETRY_DELAY_BASE","INITIAL_RETRY_TOKENS","NO_RETRY_INCREMENT","RETRY_COST","THROTTLING_RETRY_DELAY_BASE","TIMEOUT_RETRY_COST","getDefaultRetryBackoffStrategy","createDefaultRetryToken","StandardRetryStrategy","constructor","maxAttempts","_defineProperty","STANDARD","maxAttemptsProvider","acquireInitialRetryToken","retryTokenScope","retryDelay","retryCount","refreshRetryTokenForRetry","token","errorInfo","getMaxAttempts","shouldRetry","errorType","retryBackoffStrategy","setDelayBase","delayFromErrorType","computeNextBackoffDelay","getRetryCount","retryAfterHint","Math","max","getTime","Date","now","capacityCost","getCapacityCost","capacity","retryCost","Error","recordSuccess","_token$getRetryCost","getRetryCost","getCapacity","error","console","warn","concat","tokenToRenew","attempts","isRetryableError"],"sources":["/home/rcts/Email-differ/Frontend/node_modules/@smithy/util-retry/dist-es/StandardRetryStrategy.js"],"sourcesContent":["import { DEFAULT_MAX_ATTEMPTS, RETRY_MODES } from \"./config\";\nimport { DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS, NO_RETRY_INCREMENT, RETRY_COST, THROTTLING_RETRY_DELAY_BASE, TIMEOUT_RETRY_COST, } from \"./constants\";\nimport { getDefaultRetryBackoffStrategy } from \"./defaultRetryBackoffStrategy\";\nimport { createDefaultRetryToken } from \"./defaultRetryToken\";\nexport class StandardRetryStrategy {\n    maxAttempts;\n    mode = RETRY_MODES.STANDARD;\n    capacity = INITIAL_RETRY_TOKENS;\n    retryBackoffStrategy = getDefaultRetryBackoffStrategy();\n    maxAttemptsProvider;\n    constructor(maxAttempts) {\n        this.maxAttempts = maxAttempts;\n        this.maxAttemptsProvider = typeof maxAttempts === \"function\" ? maxAttempts : async () => maxAttempts;\n    }\n    async acquireInitialRetryToken(retryTokenScope) {\n        return createDefaultRetryToken({\n            retryDelay: DEFAULT_RETRY_DELAY_BASE,\n            retryCount: 0,\n        });\n    }\n    async refreshRetryTokenForRetry(token, errorInfo) {\n        const maxAttempts = await this.getMaxAttempts();\n        if (this.shouldRetry(token, errorInfo, maxAttempts)) {\n            const errorType = errorInfo.errorType;\n            this.retryBackoffStrategy.setDelayBase(errorType === \"THROTTLING\" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);\n            const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());\n            const retryDelay = errorInfo.retryAfterHint\n                ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType)\n                : delayFromErrorType;\n            const capacityCost = this.getCapacityCost(errorType);\n            this.capacity -= capacityCost;\n            return createDefaultRetryToken({\n                retryDelay,\n                retryCount: token.getRetryCount() + 1,\n                retryCost: capacityCost,\n            });\n        }\n        throw new Error(\"No retry token available\");\n    }\n    recordSuccess(token) {\n        this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));\n    }\n    getCapacity() {\n        return this.capacity;\n    }\n    async getMaxAttempts() {\n        try {\n            return await this.maxAttemptsProvider();\n        }\n        catch (error) {\n            console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);\n            return DEFAULT_MAX_ATTEMPTS;\n        }\n    }\n    shouldRetry(tokenToRenew, errorInfo, maxAttempts) {\n        const attempts = tokenToRenew.getRetryCount() + 1;\n        return (attempts < maxAttempts &&\n            this.capacity >= this.getCapacityCost(errorInfo.errorType) &&\n            this.isRetryableError(errorInfo.errorType));\n    }\n    getCapacityCost(errorType) {\n        return errorType === \"TRANSIENT\" ? TIMEOUT_RETRY_COST : RETRY_COST;\n    }\n    isRetryableError(errorType) {\n        return errorType === \"THROTTLING\" || errorType === \"TRANSIENT\";\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}