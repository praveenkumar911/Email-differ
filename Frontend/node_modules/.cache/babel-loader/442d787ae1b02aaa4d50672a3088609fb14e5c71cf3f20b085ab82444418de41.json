{"ast":null,"code":"function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n// This \"state\" object simply holds the state of the \"AsYouType\" parser:\n//\n// * `country?: string` — The exact country of the phone number, if it could be determined.\n//                        When inputting a phone number in \"international\" format, it will derive the `country` from \"country calling code\" and the phone number digits.\n//                        When inputting a phone number in \"national\" format, it will derive the `country` from `defaultCountry` that was specified when creating the `AsYouType` formatter.\n//                        Sidenote: If `USE_NON_GEOGRAPHIC_COUNTRY_CODE` flag was `true`, then for \"non-geographic phone numbers\" `state.country` would've been \"001\".\n// * `callingCode?: string` — \"Country calling code\" that has been extracted from the input phone number.\n//                        When inputting a phone number in \"international\" format, it will extract the \"country calling code\" from the digits that follow the \"+\" character.\n//                        When inputting a phone number in \"national\" format, `callingCode` will be `undefined`.\n//                        Sidenote: `state.callingCode` is therefore independent from `state.country` and there could be situations when `state.country` is defined by `state.callingCode` is not — that would be when inputting a phone number not in \"international\" format.\n// * `digits: string` — Phone number digits that have been input so far, including the \"+\" character, if present. In case of inputting non-arabic digits, those will be converted to arabic ones.\n// * `international: boolean` — Whether the phone number is being input in \"international\" format, i.e. with a \"+\" character.\n// * `missingPlus: boolean` — Whether it's a phone number in \"international\" format that is missing the leading \"+\" character for some reason — apparently, Google thinks that it's a common mistake when inputting a phone number.\n// * `IDDPrefix?: string` — An \"IDD prefix\", when the phone number is being input in an \"out-of-country dialing\" format. https://wikitravel.org/en/International_dialling_prefix\n// * `carrierCode?: string` — A \"carrier code\", if the phone number contains it. Normally, those can only be present in Colombia or Brazil, and only when calling from mobile phones to fixed-line numbers.\n// * `nationalPrefix?: string` — \"National prefix\", if present in the phone number input.\n// * `nationalSignificantNumber?: string` — National (significant) number digits that have been input so far.\n// * `nationalSignificantNumberIsModified: boolean` — Tells if the parsed national (significant) number is present as-is in the input string. For example, when inputting \"0343515551212999\" Argentinian mobile number, the parsed national (significant) number is \"93435551212999\". There, one can see how it stripped \"0\" national prefix and prepended a \"9\", because that's how it is instructed to do in Argentina's metadata. So in the described example, the parsed national (significant) number is not present as-is in the input string. Instead, it's \"modified\" in the input string. https://gitlab.com/caamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\n// * `prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix?: string` — In some countries, a phone number could have a prefix that is not a \"national prefix\" but rather some other type of \"utility\" prefix.\n//                                                                             For example, when calling within Australia, one could prepend `1831` prefix to hide caller's phone number.\n//                                                                             https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\n//\nvar AsYouTypeState = /*#__PURE__*/function () {\n  function AsYouTypeState(_ref) {\n    var onCountryChange = _ref.onCountryChange,\n      onCallingCodeChange = _ref.onCallingCodeChange;\n    _classCallCheck(this, AsYouTypeState);\n    this.onCountryChange = onCountryChange;\n    this.onCallingCodeChange = onCallingCodeChange;\n  }\n  return _createClass(AsYouTypeState, [{\n    key: \"reset\",\n    value: function reset(_ref2) {\n      var country = _ref2.country,\n        callingCode = _ref2.callingCode;\n      this.international = false;\n      this.missingPlus = false;\n      this.IDDPrefix = undefined;\n      this.callingCode = undefined;\n      this.digits = '';\n      this.resetNationalSignificantNumber();\n      this.initCountryAndCallingCode(country, callingCode);\n    }\n  }, {\n    key: \"resetNationalSignificantNumber\",\n    value: function resetNationalSignificantNumber() {\n      this.nationalSignificantNumber = this.getNationalDigits();\n      this.nationalSignificantNumberIsModified = false;\n      this.nationalPrefix = undefined;\n      this.carrierCode = undefined;\n      this.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix = undefined;\n    }\n  }, {\n    key: \"update\",\n    value: function update(properties) {\n      for (var _i = 0, _Object$keys = Object.keys(properties); _i < _Object$keys.length; _i++) {\n        var key = _Object$keys[_i];\n        this[key] = properties[key];\n      }\n    }\n  }, {\n    key: \"initCountryAndCallingCode\",\n    value: function initCountryAndCallingCode(country, callingCode) {\n      this.setCountry(country);\n      this.setCallingCode(callingCode);\n    }\n  }, {\n    key: \"setCountry\",\n    value: function setCountry(country) {\n      this.country = country;\n      this.onCountryChange(country);\n    }\n  }, {\n    key: \"setCallingCode\",\n    value: function setCallingCode(callingCode) {\n      this.callingCode = callingCode;\n      this.onCallingCodeChange(callingCode, this.country);\n    }\n  }, {\n    key: \"startInternationalNumber\",\n    value: function startInternationalNumber(country, callingCode) {\n      // Prepend the `+` to parsed input.\n      this.international = true;\n      // If a default country was set then reset it\n      // because an explicitly international phone\n      // number is being entered.\n      this.initCountryAndCallingCode(country, callingCode);\n    }\n  }, {\n    key: \"appendDigits\",\n    value: function appendDigits(nextDigits) {\n      this.digits += nextDigits;\n    }\n  }, {\n    key: \"appendNationalSignificantNumberDigits\",\n    value: function appendNationalSignificantNumberDigits(nextDigits) {\n      this.nationalSignificantNumber += nextDigits;\n    }\n\n    /**\r\n     * Returns the part of `this.digits` that corresponds to the national number.\r\n     * Basically, all digits that have been input by the user, except for the\r\n     * international prefix and the country calling code part\r\n     * (if the number is an international one).\r\n     * @return {string}\r\n     */\n  }, {\n    key: \"getNationalDigits\",\n    value: function getNationalDigits() {\n      if (this.international) {\n        return this.digits.slice((this.IDDPrefix ? this.IDDPrefix.length : 0) + (this.callingCode ? this.callingCode.length : 0));\n      }\n      return this.digits;\n    }\n  }, {\n    key: \"getDigitsWithoutInternationalPrefix\",\n    value: function getDigitsWithoutInternationalPrefix() {\n      if (this.international) {\n        if (this.IDDPrefix) {\n          return this.digits.slice(this.IDDPrefix.length);\n        }\n      }\n      return this.digits;\n    }\n  }]);\n}();\nexport { AsYouTypeState as default };","map":{"version":3,"names":["AsYouTypeState","_ref","onCountryChange","onCallingCodeChange","_classCallCheck","_createClass","key","value","reset","_ref2","country","callingCode","international","missingPlus","IDDPrefix","undefined","digits","resetNationalSignificantNumber","initCountryAndCallingCode","nationalSignificantNumber","getNationalDigits","nationalSignificantNumberIsModified","nationalPrefix","carrierCode","prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix","update","properties","_i","_Object$keys","Object","keys","length","setCountry","setCallingCode","startInternationalNumber","appendDigits","nextDigits","appendNationalSignificantNumberDigits","slice","getDigitsWithoutInternationalPrefix","default"],"sources":["/home/rcts/Email-differ/Frontend/node_modules/libphonenumber-js/source/AsYouTypeState.js"],"sourcesContent":["// This \"state\" object simply holds the state of the \"AsYouType\" parser:\r\n//\r\n// * `country?: string` — The exact country of the phone number, if it could be determined.\r\n//                        When inputting a phone number in \"international\" format, it will derive the `country` from \"country calling code\" and the phone number digits.\r\n//                        When inputting a phone number in \"national\" format, it will derive the `country` from `defaultCountry` that was specified when creating the `AsYouType` formatter.\r\n//                        Sidenote: If `USE_NON_GEOGRAPHIC_COUNTRY_CODE` flag was `true`, then for \"non-geographic phone numbers\" `state.country` would've been \"001\".\r\n// * `callingCode?: string` — \"Country calling code\" that has been extracted from the input phone number.\r\n//                        When inputting a phone number in \"international\" format, it will extract the \"country calling code\" from the digits that follow the \"+\" character.\r\n//                        When inputting a phone number in \"national\" format, `callingCode` will be `undefined`.\r\n//                        Sidenote: `state.callingCode` is therefore independent from `state.country` and there could be situations when `state.country` is defined by `state.callingCode` is not — that would be when inputting a phone number not in \"international\" format.\r\n// * `digits: string` — Phone number digits that have been input so far, including the \"+\" character, if present. In case of inputting non-arabic digits, those will be converted to arabic ones.\r\n// * `international: boolean` — Whether the phone number is being input in \"international\" format, i.e. with a \"+\" character.\r\n// * `missingPlus: boolean` — Whether it's a phone number in \"international\" format that is missing the leading \"+\" character for some reason — apparently, Google thinks that it's a common mistake when inputting a phone number.\r\n// * `IDDPrefix?: string` — An \"IDD prefix\", when the phone number is being input in an \"out-of-country dialing\" format. https://wikitravel.org/en/International_dialling_prefix\r\n// * `carrierCode?: string` — A \"carrier code\", if the phone number contains it. Normally, those can only be present in Colombia or Brazil, and only when calling from mobile phones to fixed-line numbers.\r\n// * `nationalPrefix?: string` — \"National prefix\", if present in the phone number input.\r\n// * `nationalSignificantNumber?: string` — National (significant) number digits that have been input so far.\r\n// * `nationalSignificantNumberIsModified: boolean` — Tells if the parsed national (significant) number is present as-is in the input string. For example, when inputting \"0343515551212999\" Argentinian mobile number, the parsed national (significant) number is \"93435551212999\". There, one can see how it stripped \"0\" national prefix and prepended a \"9\", because that's how it is instructed to do in Argentina's metadata. So in the described example, the parsed national (significant) number is not present as-is in the input string. Instead, it's \"modified\" in the input string. https://gitlab.com/caamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\r\n// * `prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix?: string` — In some countries, a phone number could have a prefix that is not a \"national prefix\" but rather some other type of \"utility\" prefix.\r\n//                                                                             For example, when calling within Australia, one could prepend `1831` prefix to hide caller's phone number.\r\n//                                                                             https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\r\n//\r\nexport default class AsYouTypeState {\r\n\tconstructor({ onCountryChange, onCallingCodeChange }) {\r\n\t\tthis.onCountryChange = onCountryChange\r\n\t\tthis.onCallingCodeChange = onCallingCodeChange\r\n\t}\r\n\r\n\treset({ country, callingCode }) {\r\n\t\tthis.international = false\r\n\t\tthis.missingPlus = false\r\n\t\tthis.IDDPrefix = undefined\r\n\t\tthis.callingCode = undefined\r\n\t\tthis.digits = ''\r\n\t\tthis.resetNationalSignificantNumber()\r\n\t\tthis.initCountryAndCallingCode(country, callingCode)\r\n\t}\r\n\r\n\tresetNationalSignificantNumber() {\r\n\t\tthis.nationalSignificantNumber = this.getNationalDigits()\r\n\t\tthis.nationalSignificantNumberIsModified = false\r\n\t\tthis.nationalPrefix = undefined\r\n\t\tthis.carrierCode = undefined\r\n\t\tthis.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix = undefined\r\n\t}\r\n\r\n\tupdate(properties) {\r\n\t\tfor (const key of Object.keys(properties)) {\r\n\t\t\tthis[key] = properties[key]\r\n\t\t}\r\n\t}\r\n\r\n\tinitCountryAndCallingCode(country, callingCode) {\r\n\t\tthis.setCountry(country)\r\n\t\tthis.setCallingCode(callingCode)\r\n\t}\r\n\r\n\tsetCountry(country) {\r\n\t\tthis.country = country\r\n\t\tthis.onCountryChange(country)\r\n\t}\r\n\r\n\tsetCallingCode(callingCode) {\r\n\t\tthis.callingCode = callingCode\r\n\t\tthis.onCallingCodeChange(callingCode, this.country)\r\n\t}\r\n\r\n\tstartInternationalNumber(country, callingCode) {\r\n\t\t// Prepend the `+` to parsed input.\r\n\t\tthis.international = true\r\n\t\t// If a default country was set then reset it\r\n\t\t// because an explicitly international phone\r\n\t\t// number is being entered.\r\n\t\tthis.initCountryAndCallingCode(country, callingCode)\r\n\t}\r\n\r\n\tappendDigits(nextDigits) {\r\n\t\tthis.digits += nextDigits\r\n\t}\r\n\r\n\tappendNationalSignificantNumberDigits(nextDigits) {\r\n\t\tthis.nationalSignificantNumber += nextDigits\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the part of `this.digits` that corresponds to the national number.\r\n\t * Basically, all digits that have been input by the user, except for the\r\n\t * international prefix and the country calling code part\r\n\t * (if the number is an international one).\r\n\t * @return {string}\r\n\t */\r\n\tgetNationalDigits() {\r\n\t\tif (this.international) {\r\n\t\t\treturn this.digits.slice(\r\n\t\t\t\t(this.IDDPrefix ? this.IDDPrefix.length : 0) +\r\n\t\t\t\t(this.callingCode ? this.callingCode.length : 0)\r\n\t\t\t)\r\n\t\t}\r\n\t\treturn this.digits\r\n\t}\r\n\r\n\tgetDigitsWithoutInternationalPrefix() {\r\n\t\tif (this.international) {\r\n\t\t\tif (this.IDDPrefix) {\r\n\t\t\t\treturn this.digits.slice(this.IDDPrefix.length)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.digits\r\n\t}\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}