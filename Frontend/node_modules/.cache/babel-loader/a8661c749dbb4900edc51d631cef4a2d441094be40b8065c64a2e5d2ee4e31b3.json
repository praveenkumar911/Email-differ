{"ast":null,"code":"import _objectSpread from \"/home/rcts/Email-differ/Frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"/home/rcts/Email-differ/Frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _awaitAsyncGenerator from \"/home/rcts/Email-differ/Frontend/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/home/rcts/Email-differ/Frontend/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _asyncIterator from \"/home/rcts/Email-differ/Frontend/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { fromUtf8, toUtf8 } from \"@smithy/util-utf8\";\nexport class EventStreamSerde {\n  constructor(_ref) {\n    let {\n      marshaller,\n      serializer,\n      deserializer,\n      serdeContext,\n      defaultContentType\n    } = _ref;\n    _defineProperty(this, \"marshaller\", void 0);\n    _defineProperty(this, \"serializer\", void 0);\n    _defineProperty(this, \"deserializer\", void 0);\n    _defineProperty(this, \"serdeContext\", void 0);\n    _defineProperty(this, \"defaultContentType\", void 0);\n    this.marshaller = marshaller;\n    this.serializer = serializer;\n    this.deserializer = deserializer;\n    this.serdeContext = serdeContext;\n    this.defaultContentType = defaultContentType;\n  }\n  async serializeEventStream(_ref2) {\n    let {\n      eventStream,\n      requestSchema,\n      initialRequest\n    } = _ref2;\n    const marshaller = this.marshaller;\n    const eventStreamMember = requestSchema.getEventStreamMember();\n    const unionSchema = requestSchema.getMemberSchema(eventStreamMember);\n    const serializer = this.serializer;\n    const defaultContentType = this.defaultContentType;\n    const initialRequestMarker = Symbol(\"initialRequestMarker\");\n    const eventStreamIterable = {\n      [Symbol.asyncIterator]() {\n        return _wrapAsyncGenerator(function* () {\n          if (initialRequest) {\n            const headers = {\n              \":event-type\": {\n                type: \"string\",\n                value: \"initial-request\"\n              },\n              \":message-type\": {\n                type: \"string\",\n                value: \"event\"\n              },\n              \":content-type\": {\n                type: \"string\",\n                value: defaultContentType\n              }\n            };\n            serializer.write(requestSchema, initialRequest);\n            const body = serializer.flush();\n            yield {\n              [initialRequestMarker]: true,\n              headers,\n              body\n            };\n          }\n          var _iteratorAbruptCompletion = false;\n          var _didIteratorError = false;\n          var _iteratorError;\n          try {\n            for (var _iterator = _asyncIterator(eventStream), _step; _iteratorAbruptCompletion = !(_step = yield _awaitAsyncGenerator(_iterator.next())).done; _iteratorAbruptCompletion = false) {\n              const page = _step.value;\n              {\n                yield page;\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (_iteratorAbruptCompletion && _iterator.return != null) {\n                yield _awaitAsyncGenerator(_iterator.return());\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        })();\n      }\n    };\n    return marshaller.serialize(eventStreamIterable, event => {\n      var _Object$keys$find;\n      if (event[initialRequestMarker]) {\n        return {\n          headers: event.headers,\n          body: event.body\n        };\n      }\n      const unionMember = (_Object$keys$find = Object.keys(event).find(key => {\n        return key !== \"__type\";\n      })) !== null && _Object$keys$find !== void 0 ? _Object$keys$find : \"\";\n      const {\n        additionalHeaders,\n        body,\n        eventType,\n        explicitPayloadContentType\n      } = this.writeEventBody(unionMember, unionSchema, event);\n      const headers = _objectSpread({\n        \":event-type\": {\n          type: \"string\",\n          value: eventType\n        },\n        \":message-type\": {\n          type: \"string\",\n          value: \"event\"\n        },\n        \":content-type\": {\n          type: \"string\",\n          value: explicitPayloadContentType !== null && explicitPayloadContentType !== void 0 ? explicitPayloadContentType : defaultContentType\n        }\n      }, additionalHeaders);\n      return {\n        headers,\n        body\n      };\n    });\n  }\n  async deserializeEventStream(_ref3) {\n    var _firstEvent$value;\n    let {\n      response,\n      responseSchema,\n      initialResponseContainer\n    } = _ref3;\n    const marshaller = this.marshaller;\n    const eventStreamMember = responseSchema.getEventStreamMember();\n    const unionSchema = responseSchema.getMemberSchema(eventStreamMember);\n    const memberSchemas = unionSchema.getMemberSchemas();\n    const initialResponseMarker = Symbol(\"initialResponseMarker\");\n    const asyncIterable = marshaller.deserialize(response.body, async event => {\n      var _Object$keys$find2;\n      const unionMember = (_Object$keys$find2 = Object.keys(event).find(key => {\n        return key !== \"__type\";\n      })) !== null && _Object$keys$find2 !== void 0 ? _Object$keys$find2 : \"\";\n      const body = event[unionMember].body;\n      if (unionMember === \"initial-response\") {\n        const dataObject = await this.deserializer.read(responseSchema, body);\n        delete dataObject[eventStreamMember];\n        return _objectSpread({\n          [initialResponseMarker]: true\n        }, dataObject);\n      } else if (unionMember in memberSchemas) {\n        const eventStreamSchema = memberSchemas[unionMember];\n        if (eventStreamSchema.isStructSchema()) {\n          const out = {};\n          let hasBindings = false;\n          for (const [name, member] of eventStreamSchema.structIterator()) {\n            const {\n              eventHeader,\n              eventPayload\n            } = member.getMergedTraits();\n            hasBindings = hasBindings || Boolean(eventHeader || eventPayload);\n            if (eventPayload) {\n              if (member.isBlobSchema()) {\n                out[name] = body;\n              } else if (member.isStringSchema()) {\n                var _this$serdeContext$ut, _this$serdeContext;\n                out[name] = ((_this$serdeContext$ut = (_this$serdeContext = this.serdeContext) === null || _this$serdeContext === void 0 ? void 0 : _this$serdeContext.utf8Encoder) !== null && _this$serdeContext$ut !== void 0 ? _this$serdeContext$ut : toUtf8)(body);\n              } else if (member.isStructSchema()) {\n                out[name] = await this.deserializer.read(member, body);\n              }\n            } else if (eventHeader) {\n              var _event$unionMember$he;\n              const value = (_event$unionMember$he = event[unionMember].headers[name]) === null || _event$unionMember$he === void 0 ? void 0 : _event$unionMember$he.value;\n              if (value != null) {\n                if (member.isNumericSchema()) {\n                  if (value && typeof value === \"object\" && \"bytes\" in value) {\n                    out[name] = BigInt(value.toString());\n                  } else {\n                    out[name] = Number(value);\n                  }\n                } else {\n                  out[name] = value;\n                }\n              }\n            }\n          }\n          if (hasBindings) {\n            return {\n              [unionMember]: out\n            };\n          }\n        }\n        return {\n          [unionMember]: await this.deserializer.read(eventStreamSchema, body)\n        };\n      } else {\n        return {\n          $unknown: event\n        };\n      }\n    });\n    const asyncIterator = asyncIterable[Symbol.asyncIterator]();\n    const firstEvent = await asyncIterator.next();\n    if (firstEvent.done) {\n      return asyncIterable;\n    }\n    if ((_firstEvent$value = firstEvent.value) !== null && _firstEvent$value !== void 0 && _firstEvent$value[initialResponseMarker]) {\n      if (!responseSchema) {\n        throw new Error(\"@smithy::core/protocols - initial-response event encountered in event stream but no response schema given.\");\n      }\n      for (const [key, value] of Object.entries(firstEvent.value)) {\n        initialResponseContainer[key] = value;\n      }\n    }\n    return {\n      [Symbol.asyncIterator]() {\n        return _wrapAsyncGenerator(function* () {\n          var _firstEvent$value2;\n          if (!(firstEvent !== null && firstEvent !== void 0 && (_firstEvent$value2 = firstEvent.value) !== null && _firstEvent$value2 !== void 0 && _firstEvent$value2[initialResponseMarker])) {\n            yield firstEvent.value;\n          }\n          while (true) {\n            const {\n              done,\n              value\n            } = yield _awaitAsyncGenerator(asyncIterator.next());\n            if (done) {\n              break;\n            }\n            yield value;\n          }\n        })();\n      }\n    };\n  }\n  writeEventBody(unionMember, unionSchema, event) {\n    var _this$serdeContext$ut2, _this$serdeContext2;\n    const serializer = this.serializer;\n    let eventType = unionMember;\n    let explicitPayloadMember = null;\n    let explicitPayloadContentType;\n    const isKnownSchema = (() => {\n      const struct = unionSchema.getSchema();\n      return struct[4].includes(unionMember);\n    })();\n    const additionalHeaders = {};\n    if (!isKnownSchema) {\n      const [type, value] = event[unionMember];\n      eventType = type;\n      serializer.write(15, value);\n    } else {\n      const eventSchema = unionSchema.getMemberSchema(unionMember);\n      if (eventSchema.isStructSchema()) {\n        for (const [memberName, memberSchema] of eventSchema.structIterator()) {\n          const {\n            eventHeader,\n            eventPayload\n          } = memberSchema.getMergedTraits();\n          if (eventPayload) {\n            explicitPayloadMember = memberName;\n          } else if (eventHeader) {\n            const value = event[unionMember][memberName];\n            let type = \"binary\";\n            if (memberSchema.isNumericSchema()) {\n              if ((-2) ** 31 <= value && value <= 2 ** 31 - 1) {\n                type = \"integer\";\n              } else {\n                type = \"long\";\n              }\n            } else if (memberSchema.isTimestampSchema()) {\n              type = \"timestamp\";\n            } else if (memberSchema.isStringSchema()) {\n              type = \"string\";\n            } else if (memberSchema.isBooleanSchema()) {\n              type = \"boolean\";\n            }\n            if (value != null) {\n              additionalHeaders[memberName] = {\n                type,\n                value\n              };\n              delete event[unionMember][memberName];\n            }\n          }\n        }\n        if (explicitPayloadMember !== null) {\n          const payloadSchema = eventSchema.getMemberSchema(explicitPayloadMember);\n          if (payloadSchema.isBlobSchema()) {\n            explicitPayloadContentType = \"application/octet-stream\";\n          } else if (payloadSchema.isStringSchema()) {\n            explicitPayloadContentType = \"text/plain\";\n          }\n          serializer.write(payloadSchema, event[unionMember][explicitPayloadMember]);\n        } else {\n          serializer.write(eventSchema, event[unionMember]);\n        }\n      } else {\n        throw new Error(\"@smithy/core/event-streams - non-struct member not supported in event stream union.\");\n      }\n    }\n    const messageSerialization = serializer.flush();\n    const body = typeof messageSerialization === \"string\" ? ((_this$serdeContext$ut2 = (_this$serdeContext2 = this.serdeContext) === null || _this$serdeContext2 === void 0 ? void 0 : _this$serdeContext2.utf8Decoder) !== null && _this$serdeContext$ut2 !== void 0 ? _this$serdeContext$ut2 : fromUtf8)(messageSerialization) : messageSerialization;\n    return {\n      body,\n      eventType,\n      explicitPayloadContentType,\n      additionalHeaders\n    };\n  }\n}","map":{"version":3,"names":["fromUtf8","toUtf8","EventStreamSerde","constructor","_ref","marshaller","serializer","deserializer","serdeContext","defaultContentType","_defineProperty","serializeEventStream","_ref2","eventStream","requestSchema","initialRequest","eventStreamMember","getEventStreamMember","unionSchema","getMemberSchema","initialRequestMarker","Symbol","eventStreamIterable","asyncIterator","_wrapAsyncGenerator","headers","type","value","write","body","flush","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_asyncIterator","_step","_awaitAsyncGenerator","next","done","page","err","return","serialize","event","_Object$keys$find","unionMember","Object","keys","find","key","additionalHeaders","eventType","explicitPayloadContentType","writeEventBody","_objectSpread","deserializeEventStream","_ref3","_firstEvent$value","response","responseSchema","initialResponseContainer","memberSchemas","getMemberSchemas","initialResponseMarker","asyncIterable","deserialize","_Object$keys$find2","dataObject","read","eventStreamSchema","isStructSchema","out","hasBindings","name","member","structIterator","eventHeader","eventPayload","getMergedTraits","Boolean","isBlobSchema","isStringSchema","_this$serdeContext$ut","_this$serdeContext","utf8Encoder","_event$unionMember$he","isNumericSchema","BigInt","toString","Number","$unknown","firstEvent","Error","entries","_firstEvent$value2","_this$serdeContext$ut2","_this$serdeContext2","explicitPayloadMember","isKnownSchema","struct","getSchema","includes","eventSchema","memberName","memberSchema","isTimestampSchema","isBooleanSchema","payloadSchema","messageSerialization","utf8Decoder"],"sources":["/home/rcts/Email-differ/Frontend/node_modules/@smithy/core/dist-es/submodules/event-streams/EventStreamSerde.js"],"sourcesContent":["import { fromUtf8, toUtf8 } from \"@smithy/util-utf8\";\nexport class EventStreamSerde {\n    marshaller;\n    serializer;\n    deserializer;\n    serdeContext;\n    defaultContentType;\n    constructor({ marshaller, serializer, deserializer, serdeContext, defaultContentType, }) {\n        this.marshaller = marshaller;\n        this.serializer = serializer;\n        this.deserializer = deserializer;\n        this.serdeContext = serdeContext;\n        this.defaultContentType = defaultContentType;\n    }\n    async serializeEventStream({ eventStream, requestSchema, initialRequest, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = requestSchema.getEventStreamMember();\n        const unionSchema = requestSchema.getMemberSchema(eventStreamMember);\n        const serializer = this.serializer;\n        const defaultContentType = this.defaultContentType;\n        const initialRequestMarker = Symbol(\"initialRequestMarker\");\n        const eventStreamIterable = {\n            async *[Symbol.asyncIterator]() {\n                if (initialRequest) {\n                    const headers = {\n                        \":event-type\": { type: \"string\", value: \"initial-request\" },\n                        \":message-type\": { type: \"string\", value: \"event\" },\n                        \":content-type\": { type: \"string\", value: defaultContentType },\n                    };\n                    serializer.write(requestSchema, initialRequest);\n                    const body = serializer.flush();\n                    yield {\n                        [initialRequestMarker]: true,\n                        headers,\n                        body,\n                    };\n                }\n                for await (const page of eventStream) {\n                    yield page;\n                }\n            },\n        };\n        return marshaller.serialize(eventStreamIterable, (event) => {\n            if (event[initialRequestMarker]) {\n                return {\n                    headers: event.headers,\n                    body: event.body,\n                };\n            }\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const { additionalHeaders, body, eventType, explicitPayloadContentType } = this.writeEventBody(unionMember, unionSchema, event);\n            const headers = {\n                \":event-type\": { type: \"string\", value: eventType },\n                \":message-type\": { type: \"string\", value: \"event\" },\n                \":content-type\": { type: \"string\", value: explicitPayloadContentType ?? defaultContentType },\n                ...additionalHeaders,\n            };\n            return {\n                headers,\n                body,\n            };\n        });\n    }\n    async deserializeEventStream({ response, responseSchema, initialResponseContainer, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = responseSchema.getEventStreamMember();\n        const unionSchema = responseSchema.getMemberSchema(eventStreamMember);\n        const memberSchemas = unionSchema.getMemberSchemas();\n        const initialResponseMarker = Symbol(\"initialResponseMarker\");\n        const asyncIterable = marshaller.deserialize(response.body, async (event) => {\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const body = event[unionMember].body;\n            if (unionMember === \"initial-response\") {\n                const dataObject = await this.deserializer.read(responseSchema, body);\n                delete dataObject[eventStreamMember];\n                return {\n                    [initialResponseMarker]: true,\n                    ...dataObject,\n                };\n            }\n            else if (unionMember in memberSchemas) {\n                const eventStreamSchema = memberSchemas[unionMember];\n                if (eventStreamSchema.isStructSchema()) {\n                    const out = {};\n                    let hasBindings = false;\n                    for (const [name, member] of eventStreamSchema.structIterator()) {\n                        const { eventHeader, eventPayload } = member.getMergedTraits();\n                        hasBindings = hasBindings || Boolean(eventHeader || eventPayload);\n                        if (eventPayload) {\n                            if (member.isBlobSchema()) {\n                                out[name] = body;\n                            }\n                            else if (member.isStringSchema()) {\n                                out[name] = (this.serdeContext?.utf8Encoder ?? toUtf8)(body);\n                            }\n                            else if (member.isStructSchema()) {\n                                out[name] = await this.deserializer.read(member, body);\n                            }\n                        }\n                        else if (eventHeader) {\n                            const value = event[unionMember].headers[name]?.value;\n                            if (value != null) {\n                                if (member.isNumericSchema()) {\n                                    if (value && typeof value === \"object\" && \"bytes\" in value) {\n                                        out[name] = BigInt(value.toString());\n                                    }\n                                    else {\n                                        out[name] = Number(value);\n                                    }\n                                }\n                                else {\n                                    out[name] = value;\n                                }\n                            }\n                        }\n                    }\n                    if (hasBindings) {\n                        return {\n                            [unionMember]: out,\n                        };\n                    }\n                }\n                return {\n                    [unionMember]: await this.deserializer.read(eventStreamSchema, body),\n                };\n            }\n            else {\n                return {\n                    $unknown: event,\n                };\n            }\n        });\n        const asyncIterator = asyncIterable[Symbol.asyncIterator]();\n        const firstEvent = await asyncIterator.next();\n        if (firstEvent.done) {\n            return asyncIterable;\n        }\n        if (firstEvent.value?.[initialResponseMarker]) {\n            if (!responseSchema) {\n                throw new Error(\"@smithy::core/protocols - initial-response event encountered in event stream but no response schema given.\");\n            }\n            for (const [key, value] of Object.entries(firstEvent.value)) {\n                initialResponseContainer[key] = value;\n            }\n        }\n        return {\n            async *[Symbol.asyncIterator]() {\n                if (!firstEvent?.value?.[initialResponseMarker]) {\n                    yield firstEvent.value;\n                }\n                while (true) {\n                    const { done, value } = await asyncIterator.next();\n                    if (done) {\n                        break;\n                    }\n                    yield value;\n                }\n            },\n        };\n    }\n    writeEventBody(unionMember, unionSchema, event) {\n        const serializer = this.serializer;\n        let eventType = unionMember;\n        let explicitPayloadMember = null;\n        let explicitPayloadContentType;\n        const isKnownSchema = (() => {\n            const struct = unionSchema.getSchema();\n            return struct[4].includes(unionMember);\n        })();\n        const additionalHeaders = {};\n        if (!isKnownSchema) {\n            const [type, value] = event[unionMember];\n            eventType = type;\n            serializer.write(15, value);\n        }\n        else {\n            const eventSchema = unionSchema.getMemberSchema(unionMember);\n            if (eventSchema.isStructSchema()) {\n                for (const [memberName, memberSchema] of eventSchema.structIterator()) {\n                    const { eventHeader, eventPayload } = memberSchema.getMergedTraits();\n                    if (eventPayload) {\n                        explicitPayloadMember = memberName;\n                    }\n                    else if (eventHeader) {\n                        const value = event[unionMember][memberName];\n                        let type = \"binary\";\n                        if (memberSchema.isNumericSchema()) {\n                            if ((-2) ** 31 <= value && value <= 2 ** 31 - 1) {\n                                type = \"integer\";\n                            }\n                            else {\n                                type = \"long\";\n                            }\n                        }\n                        else if (memberSchema.isTimestampSchema()) {\n                            type = \"timestamp\";\n                        }\n                        else if (memberSchema.isStringSchema()) {\n                            type = \"string\";\n                        }\n                        else if (memberSchema.isBooleanSchema()) {\n                            type = \"boolean\";\n                        }\n                        if (value != null) {\n                            additionalHeaders[memberName] = {\n                                type,\n                                value,\n                            };\n                            delete event[unionMember][memberName];\n                        }\n                    }\n                }\n                if (explicitPayloadMember !== null) {\n                    const payloadSchema = eventSchema.getMemberSchema(explicitPayloadMember);\n                    if (payloadSchema.isBlobSchema()) {\n                        explicitPayloadContentType = \"application/octet-stream\";\n                    }\n                    else if (payloadSchema.isStringSchema()) {\n                        explicitPayloadContentType = \"text/plain\";\n                    }\n                    serializer.write(payloadSchema, event[unionMember][explicitPayloadMember]);\n                }\n                else {\n                    serializer.write(eventSchema, event[unionMember]);\n                }\n            }\n            else {\n                throw new Error(\"@smithy/core/event-streams - non-struct member not supported in event stream union.\");\n            }\n        }\n        const messageSerialization = serializer.flush();\n        const body = typeof messageSerialization === \"string\"\n            ? (this.serdeContext?.utf8Decoder ?? fromUtf8)(messageSerialization)\n            : messageSerialization;\n        return {\n            body,\n            eventType,\n            explicitPayloadContentType,\n            additionalHeaders,\n        };\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}