{"ast":null,"code":"import _objectSpread from \"/home/rcts/Email-differ/Frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { setFeature } from \"@aws-sdk/core\";\nimport { HttpRequest } from \"@smithy/protocol-http\";\nimport { createBufferedReadable } from \"@smithy/util-stream\";\nimport { ChecksumAlgorithm, DEFAULT_CHECKSUM_ALGORITHM, RequestChecksumCalculation } from \"./constants\";\nimport { getChecksumAlgorithmForRequest } from \"./getChecksumAlgorithmForRequest\";\nimport { getChecksumLocationName } from \"./getChecksumLocationName\";\nimport { hasHeader } from \"./hasHeader\";\nimport { hasHeaderWithPrefix } from \"./hasHeaderWithPrefix\";\nimport { isStreaming } from \"./isStreaming\";\nimport { selectChecksumAlgorithmFunction } from \"./selectChecksumAlgorithmFunction\";\nimport { stringHasher } from \"./stringHasher\";\nexport const flexibleChecksumsMiddlewareOptions = {\n  name: \"flexibleChecksumsMiddleware\",\n  step: \"build\",\n  tags: [\"BODY_CHECKSUM\"],\n  override: true\n};\nexport const flexibleChecksumsMiddleware = (config, middlewareConfig) => (next, context) => async args => {\n  if (!HttpRequest.isInstance(args.request)) {\n    return next(args);\n  }\n  if (hasHeaderWithPrefix(\"x-amz-checksum-\", args.request.headers)) {\n    return next(args);\n  }\n  const {\n    request,\n    input\n  } = args;\n  const {\n    body: requestBody,\n    headers\n  } = request;\n  const {\n    base64Encoder,\n    streamHasher\n  } = config;\n  const {\n    requestChecksumRequired,\n    requestAlgorithmMember\n  } = middlewareConfig;\n  const requestChecksumCalculation = await config.requestChecksumCalculation();\n  const requestAlgorithmMemberName = requestAlgorithmMember === null || requestAlgorithmMember === void 0 ? void 0 : requestAlgorithmMember.name;\n  const requestAlgorithmMemberHttpHeader = requestAlgorithmMember === null || requestAlgorithmMember === void 0 ? void 0 : requestAlgorithmMember.httpHeader;\n  if (requestAlgorithmMemberName && !input[requestAlgorithmMemberName]) {\n    if (requestChecksumCalculation === RequestChecksumCalculation.WHEN_SUPPORTED || requestChecksumRequired) {\n      input[requestAlgorithmMemberName] = DEFAULT_CHECKSUM_ALGORITHM;\n      if (requestAlgorithmMemberHttpHeader) {\n        headers[requestAlgorithmMemberHttpHeader] = DEFAULT_CHECKSUM_ALGORITHM;\n      }\n    }\n  }\n  const checksumAlgorithm = getChecksumAlgorithmForRequest(input, {\n    requestChecksumRequired,\n    requestAlgorithmMember: requestAlgorithmMember === null || requestAlgorithmMember === void 0 ? void 0 : requestAlgorithmMember.name,\n    requestChecksumCalculation\n  });\n  let updatedBody = requestBody;\n  let updatedHeaders = headers;\n  if (checksumAlgorithm) {\n    switch (checksumAlgorithm) {\n      case ChecksumAlgorithm.CRC32:\n        setFeature(context, \"FLEXIBLE_CHECKSUMS_REQ_CRC32\", \"U\");\n        break;\n      case ChecksumAlgorithm.CRC32C:\n        setFeature(context, \"FLEXIBLE_CHECKSUMS_REQ_CRC32C\", \"V\");\n        break;\n      case ChecksumAlgorithm.CRC64NVME:\n        setFeature(context, \"FLEXIBLE_CHECKSUMS_REQ_CRC64\", \"W\");\n        break;\n      case ChecksumAlgorithm.SHA1:\n        setFeature(context, \"FLEXIBLE_CHECKSUMS_REQ_SHA1\", \"X\");\n        break;\n      case ChecksumAlgorithm.SHA256:\n        setFeature(context, \"FLEXIBLE_CHECKSUMS_REQ_SHA256\", \"Y\");\n        break;\n    }\n    const checksumLocationName = getChecksumLocationName(checksumAlgorithm);\n    const checksumAlgorithmFn = selectChecksumAlgorithmFunction(checksumAlgorithm, config);\n    if (isStreaming(requestBody)) {\n      const {\n        getAwsChunkedEncodingStream,\n        bodyLengthChecker\n      } = config;\n      updatedBody = getAwsChunkedEncodingStream(typeof config.requestStreamBufferSize === \"number\" && config.requestStreamBufferSize >= 8 * 1024 ? createBufferedReadable(requestBody, config.requestStreamBufferSize, context.logger) : requestBody, {\n        base64Encoder,\n        bodyLengthChecker,\n        checksumLocationName,\n        checksumAlgorithmFn,\n        streamHasher\n      });\n      updatedHeaders = _objectSpread(_objectSpread({}, headers), {}, {\n        \"content-encoding\": headers[\"content-encoding\"] ? \"\".concat(headers[\"content-encoding\"], \",aws-chunked\") : \"aws-chunked\",\n        \"transfer-encoding\": \"chunked\",\n        \"x-amz-decoded-content-length\": headers[\"content-length\"],\n        \"x-amz-content-sha256\": \"STREAMING-UNSIGNED-PAYLOAD-TRAILER\",\n        \"x-amz-trailer\": checksumLocationName\n      });\n      delete updatedHeaders[\"content-length\"];\n    } else if (!hasHeader(checksumLocationName, headers)) {\n      const rawChecksum = await stringHasher(checksumAlgorithmFn, requestBody);\n      updatedHeaders = _objectSpread(_objectSpread({}, headers), {}, {\n        [checksumLocationName]: base64Encoder(rawChecksum)\n      });\n    }\n  }\n  try {\n    const result = await next(_objectSpread(_objectSpread({}, args), {}, {\n      request: _objectSpread(_objectSpread({}, request), {}, {\n        headers: updatedHeaders,\n        body: updatedBody\n      })\n    }));\n    return result;\n  } catch (e) {\n    if (e instanceof Error && e.name === \"InvalidChunkSizeError\") {\n      try {\n        if (!e.message.endsWith(\".\")) {\n          e.message += \".\";\n        }\n        e.message += \" Set [requestStreamBufferSize=number e.g. 65_536] in client constructor to instruct AWS SDK to buffer your input stream.\";\n      } catch (ignored) {}\n    }\n    throw e;\n  }\n};","map":{"version":3,"names":["setFeature","HttpRequest","createBufferedReadable","ChecksumAlgorithm","DEFAULT_CHECKSUM_ALGORITHM","RequestChecksumCalculation","getChecksumAlgorithmForRequest","getChecksumLocationName","hasHeader","hasHeaderWithPrefix","isStreaming","selectChecksumAlgorithmFunction","stringHasher","flexibleChecksumsMiddlewareOptions","name","step","tags","override","flexibleChecksumsMiddleware","config","middlewareConfig","next","context","args","isInstance","request","headers","input","body","requestBody","base64Encoder","streamHasher","requestChecksumRequired","requestAlgorithmMember","requestChecksumCalculation","requestAlgorithmMemberName","requestAlgorithmMemberHttpHeader","httpHeader","WHEN_SUPPORTED","checksumAlgorithm","updatedBody","updatedHeaders","CRC32","CRC32C","CRC64NVME","SHA1","SHA256","checksumLocationName","checksumAlgorithmFn","getAwsChunkedEncodingStream","bodyLengthChecker","requestStreamBufferSize","logger","_objectSpread","concat","rawChecksum","result","e","Error","message","endsWith","ignored"],"sources":["/home/rcts/Email-differ/Frontend/node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsMiddleware.js"],"sourcesContent":["import { setFeature } from \"@aws-sdk/core\";\nimport { HttpRequest } from \"@smithy/protocol-http\";\nimport { createBufferedReadable } from \"@smithy/util-stream\";\nimport { ChecksumAlgorithm, DEFAULT_CHECKSUM_ALGORITHM, RequestChecksumCalculation } from \"./constants\";\nimport { getChecksumAlgorithmForRequest } from \"./getChecksumAlgorithmForRequest\";\nimport { getChecksumLocationName } from \"./getChecksumLocationName\";\nimport { hasHeader } from \"./hasHeader\";\nimport { hasHeaderWithPrefix } from \"./hasHeaderWithPrefix\";\nimport { isStreaming } from \"./isStreaming\";\nimport { selectChecksumAlgorithmFunction } from \"./selectChecksumAlgorithmFunction\";\nimport { stringHasher } from \"./stringHasher\";\nexport const flexibleChecksumsMiddlewareOptions = {\n    name: \"flexibleChecksumsMiddleware\",\n    step: \"build\",\n    tags: [\"BODY_CHECKSUM\"],\n    override: true,\n};\nexport const flexibleChecksumsMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {\n    if (!HttpRequest.isInstance(args.request)) {\n        return next(args);\n    }\n    if (hasHeaderWithPrefix(\"x-amz-checksum-\", args.request.headers)) {\n        return next(args);\n    }\n    const { request, input } = args;\n    const { body: requestBody, headers } = request;\n    const { base64Encoder, streamHasher } = config;\n    const { requestChecksumRequired, requestAlgorithmMember } = middlewareConfig;\n    const requestChecksumCalculation = await config.requestChecksumCalculation();\n    const requestAlgorithmMemberName = requestAlgorithmMember?.name;\n    const requestAlgorithmMemberHttpHeader = requestAlgorithmMember?.httpHeader;\n    if (requestAlgorithmMemberName && !input[requestAlgorithmMemberName]) {\n        if (requestChecksumCalculation === RequestChecksumCalculation.WHEN_SUPPORTED || requestChecksumRequired) {\n            input[requestAlgorithmMemberName] = DEFAULT_CHECKSUM_ALGORITHM;\n            if (requestAlgorithmMemberHttpHeader) {\n                headers[requestAlgorithmMemberHttpHeader] = DEFAULT_CHECKSUM_ALGORITHM;\n            }\n        }\n    }\n    const checksumAlgorithm = getChecksumAlgorithmForRequest(input, {\n        requestChecksumRequired,\n        requestAlgorithmMember: requestAlgorithmMember?.name,\n        requestChecksumCalculation,\n    });\n    let updatedBody = requestBody;\n    let updatedHeaders = headers;\n    if (checksumAlgorithm) {\n        switch (checksumAlgorithm) {\n            case ChecksumAlgorithm.CRC32:\n                setFeature(context, \"FLEXIBLE_CHECKSUMS_REQ_CRC32\", \"U\");\n                break;\n            case ChecksumAlgorithm.CRC32C:\n                setFeature(context, \"FLEXIBLE_CHECKSUMS_REQ_CRC32C\", \"V\");\n                break;\n            case ChecksumAlgorithm.CRC64NVME:\n                setFeature(context, \"FLEXIBLE_CHECKSUMS_REQ_CRC64\", \"W\");\n                break;\n            case ChecksumAlgorithm.SHA1:\n                setFeature(context, \"FLEXIBLE_CHECKSUMS_REQ_SHA1\", \"X\");\n                break;\n            case ChecksumAlgorithm.SHA256:\n                setFeature(context, \"FLEXIBLE_CHECKSUMS_REQ_SHA256\", \"Y\");\n                break;\n        }\n        const checksumLocationName = getChecksumLocationName(checksumAlgorithm);\n        const checksumAlgorithmFn = selectChecksumAlgorithmFunction(checksumAlgorithm, config);\n        if (isStreaming(requestBody)) {\n            const { getAwsChunkedEncodingStream, bodyLengthChecker } = config;\n            updatedBody = getAwsChunkedEncodingStream(typeof config.requestStreamBufferSize === \"number\" && config.requestStreamBufferSize >= 8 * 1024\n                ? createBufferedReadable(requestBody, config.requestStreamBufferSize, context.logger)\n                : requestBody, {\n                base64Encoder,\n                bodyLengthChecker,\n                checksumLocationName,\n                checksumAlgorithmFn,\n                streamHasher,\n            });\n            updatedHeaders = {\n                ...headers,\n                \"content-encoding\": headers[\"content-encoding\"]\n                    ? `${headers[\"content-encoding\"]},aws-chunked`\n                    : \"aws-chunked\",\n                \"transfer-encoding\": \"chunked\",\n                \"x-amz-decoded-content-length\": headers[\"content-length\"],\n                \"x-amz-content-sha256\": \"STREAMING-UNSIGNED-PAYLOAD-TRAILER\",\n                \"x-amz-trailer\": checksumLocationName,\n            };\n            delete updatedHeaders[\"content-length\"];\n        }\n        else if (!hasHeader(checksumLocationName, headers)) {\n            const rawChecksum = await stringHasher(checksumAlgorithmFn, requestBody);\n            updatedHeaders = {\n                ...headers,\n                [checksumLocationName]: base64Encoder(rawChecksum),\n            };\n        }\n    }\n    try {\n        const result = await next({\n            ...args,\n            request: {\n                ...request,\n                headers: updatedHeaders,\n                body: updatedBody,\n            },\n        });\n        return result;\n    }\n    catch (e) {\n        if (e instanceof Error && e.name === \"InvalidChunkSizeError\") {\n            try {\n                if (!e.message.endsWith(\".\")) {\n                    e.message += \".\";\n                }\n                e.message +=\n                    \" Set [requestStreamBufferSize=number e.g. 65_536] in client constructor to instruct AWS SDK to buffer your input stream.\";\n            }\n            catch (ignored) {\n            }\n        }\n        throw e;\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}